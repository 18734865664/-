### defer

defer关键字后可以是普通函数或方法

    当defer语句被执行时，跟在defer后面的函数会被延迟执行，知道包含defer语句的函数执行完毕后，defer后的函数才会被执行

    有多个defer声明时，执行顺序与声明的顺序相反（栈区特征，先入后出），注意，入栈时各项变量已初始化，所以defer后跟的是语句时执行结果会有偏差，可以通过匿名函数，实现输出最终结果

	函数有返回值的时候，defer中的语句会在return更新完所有变量（包括返回值）后再执行，
    
小技巧：

    使用defer + 匿名内部函数 可以输出或改变函数的输入参数及返回值（可以更改return之后的返回值数据）
    
    
执行顺序：
	执行在return之后，堆栈内容释放之前
    
循环体内部资源回收

    因为defer只有在函数结束时才会执行，当defer位于循环体语句重视，由于for循环结束时，defer并不会执行，这时通过defer语句对单词循环打开的文件描述符进行关闭并不能起到作用，可能引起文件描述符耗尽，连接池打满
    
    解决方法：将资源申请（文件打开，socket连接等）及defer语句封装于单独的方法，每次循环时调用该函数
    
    
文件描述符关闭

    不同文件系统对于创建/打开文件时的错误反馈不同，尤其时NFS，写入文件时发生的错误会被延迟到文件关闭时反馈，所有务必对f.close返回信息进行分析
    
    
    
### panic异常

程序panic异常
	
    Go的类型系统会在编译时捕获很多错误，但有些错误只能在运行时检查，如数组访问越界、空指针引用等，这些运行时错误会引起panic异常

	当panic异常发生时，程序会立即中断运行，并立即执行该goroutine中被延迟的函数（defer），然后输出日志  
	程序崩溃后，输出的日志中包含panic value和函数调用的堆栈跟踪信息
    go的panic机制中，延迟函数的调用在释放堆栈信息之前
    
手动触发panic

    调用内置panic函数，可以除法panic异常
    panic函数接收任意类型的值作为参数
    
慎用panic
	
    由于panic会引发程序崩溃，所以要慎用
    
    
### recover 捕获异常
简介
    
    通常，对panic异常通常不做任何处理，
    但必要时可以从异常中恢复，在崩溃之前对资源回收，关闭连接，返回错误信息调试等
    
    未发生panic异常，调用recover()返回nil
    
recover使用

    recover 需要定义在defer语句中才能生效
    定义defer的代码块，需要在引发异常的代码之前才能执行
    
    
慎用recover

    不加区分的恢复所有的panic异常不可取，因为在panic之后，无法保证包级别变量的状态仍然跟预期一致
    
    有时候。乱用recover会引起资源泄露
    
    某些情况下，panic无法被恢复，如内存不足时，会导致go在运行时终止程序
    
    
    