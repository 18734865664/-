### 函数
		函数的类型：两个函数形参列表和返回值列表中的变量类型一一对应，两个函数被认为有相同的类型和标识符
		go函数调用时，Go语言没有默认参数值，也没有任何方法可以通过参数名指定形参，因此形参和返回值的变量名对于函数调用者而言没有意义
	
		函数的参数传递，都是值传递
	    
	    go语言中引用传递的实现，可以使用指针/slice/map作为载体
	    
	    函数名是一个地址值，所以全局唯一

#### 错误处理方式
panic错误，是指编译时发生的一直类型错误
1. 将错误作为返回值，返回给调用函数，一般都是发生一直类型的错误
2. 发生的错误是偶然性的，通过重试机制探测
    1. time.Second << uint(tries) 随着重试次数增加，增加重试间隔
3. 出现程序无法继续运行的错误，输出错误信息并结束程序
	1. 使用os.Exit(tag int)  进行中断
	2. 使用log.FalalF(format, ....)    会中断程序，并输出错误，有错误发生时的时间戳
	3. log.SetPrefix("prefix: ")     为日志信息增加一个前缀
	4. log.SetFlags(flag int)        // 设置为0， 会屏蔽时间戳
4. 只输出错误信息，不中断程序
	1. log.Printf(format, ....)             // 输出错误到控制台
	2. log.Fprintf(os.Stderr, format, ....)     // 将错误信息输出到标准错误流
5. 忽略错误


#### 文件结尾错误（EOF）
io.EOF 任何由文件结束引起的读取失败，都会返回io.EOF



### 匿名函数
		匿名函数在函数体内部，可以操作函数中（外部函数）的局部变量
 		匿名函数和外部函数之间存在着变量引用传递

		函数返回值中可能会存在函数体，匿名函数中有变量引用，所以函数值属于引用类型,和函数值不可比较
	
		匿名内部函数引用的所有外部函数变量都是引用传递
	    匿名内部函数，实例化后，数据存放在堆区，栈区没有实际变量指向该内存位置

> go语言中闭包，就是返回一个匿名函数的实现，价值在于该匿名函数可以随着变量进行传递，而且不会随着一个函数堆区的销毁而销毁，在一定程度实现数据共享

### 循环体变量作用域

    	循环语句中，条件控制语句内定义的变量，在整个循环过程中，都使用的同一内存地址，引用传递，每一轮循环，在该内存地址中替换数据，但是循环体内部保留的是引用传递


​    
​    
### 不定参函数
		使用三个点号... 作为不定参接收和传递的表示（接收和传递都是切片）

### 特殊
    go语言中，函数的形参不能设定默认值，没有任何手段可以实现这个需求，所以形参的名称跟实参变量名没有任何对应关系

   

### 回调函数

	本质：函数指针，通过地址在某一特定位置，调用函数
	在程序中定义一个函数，但不显式调用，但某一条件满足时，有操作系统自动调用
	回调函数就是多态的实现原理