位运算简介及实用技巧（一）：基础篇


####原码，反码，补码

		首先，根据运算法则减去一个正数等于加上一个负数， 即: 1-1 = 1+(-1)， 所以计算机被设计成只有加法而没有减法， 而让计算机辨别”符号位”会让计算机的基础电路设计变得十分复杂，于是就让符号位也参与运算，从而产生了反码。

    	用反码计算， 出现了”0”这个特殊的数值， 0带符号是没有任何意义的。 而且会有[0000 0000]和[1000 0000]两个编码表示0。于是设计了补码， 负数的补码就是反码+1，正数的补码就是正数本身，从而解决了0的符号以及两个编码的问题: 用[0000 0000]表示0，用[1000 0000]表示-128。 


		原码，二进制中第一个数表示是正数还是负数（如matrix67所说) ，剩下的数表示所要表示的数的绝对值.比如，0010=2,  1010=-2
		反码，因为原码在计算机中不方便，引入了反码，反码就是负数在二进制中除了第一个数表示符号外，其他的数都依次取反，比如127=01111111，而-127=10000000；正数的反码与原码一致
        反码作用：解决负数加法运算问题,将减法运算转换为加法运算
		补码，虽然反码方便但是在计算中会错（正数和负数的计算），因为0000=0,1111=-0=0;有两个数表示
      同一个数，所以在计算中会少一，补码就是在负数的反码上加上一。
      比如-5=11111010（反码），补码为-5=11111011。

      	数值在计算机中表示形式为机器数,计算机只能识别0和1,使用的是二进制,而在日常生活中人们使用的是十进制,"正如亚里士多德早就指出的那样,今天十进制的广泛采用,只不过我们绝大多数人生来具有10个手指头这个解剖学事实的结果.尽管在历史上手指计数(5,10进制)的实践要比二或三进制计数出现的晚."(摘自<<数学发展史>>有空大家可以看看哦~,很有意思的).为了能方便的与二进制转换,就使用了十六进制(2 4)和八进制(23).下面进入正题. 
		数值有正负之分,计算机就用一个数的最高位存放符号(0为正,1为负).这就是机器数的原码了.假设机器能处理的位数为8.即字长为1byte,原码能表示数值的范围为 (-127~-0 +0~127)共256个. 
		有了数值的表示方法就可以对数进行算术运算.但是很快就发现用带符号位的原码进行乘除运算时结果正确,而在加减运算的时候就出现了问题,如下: 假设字长为8bits 
			( 1 ) 10- ( 1 )10 = ( 1 )10 + ( -1 )10 = ( 0 )10 
			(00000001)原 + (10000001)原 = (10000010)原 = ( -2 ) 显然不正确. 
		因为在两个整数的加法运算中是没有问题的,于是就发现问题出现在带符号位的负数身上,对除符号位外的其余各位逐位取反就产生了反码.反码的取值空间和原码相同且一一对应. 下面是反码的减法运算: 
			( 1 )10 - ( 1 ) 10= ( 1 ) 10+ ( -1 ) 10= ( 0 )10 
			(00000001) 反+ (11111110)反 = (11111111)反 = ( -0 ) 有问题. 
			( 1 )10 - ( 2)10 = ( 1 )10 + ( -2 )10 = ( -1 )10 
			(00000001) 反+ (11111101)反 = (11111110)反 = ( -1 ) 正确 
		问题出现在(+0)和(-0)上,在人们的计算概念中零是没有正负之分的.(印度人首先将零作为标记并放入运算之中,包含有零号的印度数学和十进制计数对人类文明的贡献极大). 
		于是就引入了补码概念. 负数的补码就是对反码加一,而正数不变,正数的原码反码补码是一样的.在补码中用(-128)代替了(-0),所以补码的表示范围为: 
			(-128~0~127)共256个. 
		注意:(-128)没有相对应的原码和反码, (-128) = (10000000) 补码的加减运算如下: 
			( 1 ) 10- ( 1 ) 10= ( 1 )10 + ( -1 )10 = ( 0 )10 
			(00000001)补 + (11111111)补 = (00000000)补 = ( 0 ) 正确 
			( 1 ) 10- ( 2) 10= ( 1 )10 + ( -2 )10 = ( -1 )10 
			(00000001) 补+ (11111110) 补= (11111111)补 = ( -1 ) 正确 
		所以补码的设计目的是: 
			⑴使符号位能与有效值部分一起参加运算,从而简化运算规则. 
			⑵使减法运算转换为加法运算,进一步简化计算机中运算器的线路设计 
		所有这些转换都是在计算机的最底层进行的，而在我们使用的汇编、C等其他高级语言中使用的都是原码。

什么是位运算？

    程序中的所有数在计算机内存中都是以二进制的形式储存的。位运算说穿了，就是直接对整数在内存中的二进制位进行操作。比如，and运算本来是一个逻辑运算符，但整数与整数之间也可以进行and运算。举个例子，6的二进制是110，11的二进制是1011，那么6 and 11的结果就是2，它是二进制对应位进行逻辑运算的结果（0表示False，1表示True，空位都当0处理）

计算式：

         110
    AND 1011
    ————————————
        0010  –>  2
由于位运算直接对内存数据进行操作，不需要转成十进制，因此处理速度非常快。当然有人会说，这个快了有什么用，计算6 and 11没有什么实际意义啊。这一系列的文章就将告诉你，位运算到底可以干什么，有些什么经典应用，以及如何用位运算优化你的程序。

++Pascal和C中的位运算符号，下面的a和b都是整数类型，则：

	C语言  |  Pascal语言
	———————————————————
	a & b  |  a and b
	a | b  |  a or b
	a ^ b  |  a xor b
	  ~a   |   not a
	a << b |  a shl b
	a >> b |  a shr b
    
    注意C中的逻辑运算和位运算符号是不同的。520|1314=1834，但520||1314=1，因为逻辑运算时520和1314都相当于True。同样的，!a和~a也是有区别的。

### 各种位运算的使用
##### === 1. and运算 ===
    	and运算通常用于二进制取位操作，例如一个数 and 1的结果就是取二进制的最末位。这可以用来判断一个整数的奇偶，二进制的最末位为0表示该数为偶数，最末位为1表示该数为奇数.
    	相同位的两个数字都为1，则为1；若有一个不为1，则为0。
                   00101
	（&；或者and） 11100
	——————————————————————
				   00100

#####  === 2. or运算 ===
    	or运算通常用于二进制特定位上的无条件赋值，例如一个数or 1的结果就是把二进制最末位强行变成1。如果需要把二进制最末位变成0，对这个数or 1之后再减一就可以了，其实际意义就是把这个数强行变成最接近的偶数。
		相同位只要一个为1即为1。
			   00101
	（|或者or）11100
	——————————————————
		   	11101


#####=== 3. xor运算 ===
    	xor运算通常用于对二进制的特定一位进行取反操作，因为异或可以这样定义：
        0和1异或0都不变，异或1则取反。（或者认为同则为0， 异则为1）
    	xor运算的逆运算是它本身，也就是说两次异或同一个数最后结果不变，即(a xor b) xor b = a。xor运算可以用于简单的加密，比如我想对我MM说1314520，但怕别人知道，于是双方约定拿我的生日19880516作为密钥。1314520 xor 19880516 = 20665500，我就把20665500告诉MM。MM再次计算20665500 xor 19880516的值，得到1314520，于是她就明白了我的企图。
    	下面我们看另外一个东西。定义两个符号#和@（我怎么找不到那个圈里有个叉的字符），这两个符号互为逆运算，也就是说(x # y) @ y = x。现在依次执行下面三条命令，结果是什么？
		x ：= x # y
		y ：= x @ y
		x ：= x @ y

    	执行了第一句后x变成了x # y。那么第二句实质就是y <- x # y @ y，由于#和@互为逆运算，那么此时的y变成了原来的x。第三句中x实际上被赋值为(x # y) @ x，如果#运算具有交换律，那么赋值后x就变成最初的y了。这三句话的结果是，x和y的位置互换了。
    	加法和减法互为逆运算，并且加法满足交换律。把#换成+，把@换成-，我们可以写出一个不需要临时变量的swap过程(Pascal)。
		procedure swap(var a,b:longint);
		begin
		   a:=a + b;
		   b:=a - b;
		   a:=a - b;
		end;

        好了，刚才不是说xor的逆运算是它本身吗？于是我们就有了一个看起来非常诡异的swap过程：
		procedure swap(var a,b:longint);
		begin
		   a:=a xor b;
		   b:=a xor b;
		   a:=a xor b;
		end;

#####=== 4. not运算 ===
    	not运算的定义是把内存中的0和1全部取反。
    	使用not运算时要格外小心，你需要注意整数类型有没有符号。如果not的对象是无符号整数（不能表示负数），那么得到的值就是它与该类型上界的差，因为无符号类型的数是用$0000到$FFFF依次表示的。下面的两个程序（仅语言不同）均返回65535。
		var
		   a:word;
		begin
		   a:=100;
		   a:=not a;
		   writeln(a);
		end.

		#include <stdio.h>
		int main()
		{
		    unsigned short a=100;
		    a = ~a;
		    printf( "%dn", a );    
		    return 0;
		}

    	如果not的对象是有符号的整数，情况就不一样了，稍后我们会在“整数类型的储存”小节中提到。
		注意：位运算版本的交换两数不适用于一个数的自我交换。也就是说，如果上述程序的“b”改成“a”的话，其结果是变量a变成零。因此，在使用快速排序时，由于涉及到一个数的自我交换，因此如果要在其中使用位运算版的交换两数的话，应该先判断。具体的时间损耗在此略过。
#####=== 5. shl运算 ===
    	a shl b就表示把a转为二进制后左移b位（在后面添b个0）。例如100的二进制为1100100，而110010000转成十进制是400，那么100 shl 2 = 400。可以看出，a shl b的值实际上就是a乘以2的b次方，因为在二进制数后添一个0就相当于该数乘以2。
    	通常认为a shl 1比a * 2更快，因为前者是更底层一些的操作。因此程序中乘以2的操作请尽量用左移一位来代替。
    	定义一些常量可能会用到shl运算。你可以方便地用1 shl 16 – 1来表示65535。很多算法和数据结构要求数据规模必须是2的幂，此时可以用shl来定义Max_N等常量。

#####=== 6. shr运算 ===
    	和shl相似，a shr b表示二进制右移b位（去掉末b位），相当于a除以2的b次方（取整）。我们也经常用shr 1来代替div 2，比如二分查找、堆的插入操作等等。想办法用shr代替除法运算可以使程序效率大大提高。最大公约数的二进制算法用除以2操作来代替慢得出奇的mod运算，效率可以提高60%。

####位运算的简单应用

    有时我们的程序需要一个规模不大的Hash表来记录状态。比如，做数独时我们需要27个Hash表来统计每一行、每一列和每一个小九宫格里已经有哪些数了。此时，我们可以用27个小于2^9的整数进行记录。例如，一个只填了2和5的小九宫格就用数字18表示（二进制为000010010），而某一行的状态为511则表示这一行已经填满。需要改变状态时我们不需要把这个数转成二进制修改后再转回去，而是直接进行位操作。在搜索时，把状态表示成整数可以更好地进行判重等操作。这道题是在搜索中使用位运算加速的经典例子。以后我们会看到更多的例子。
    
下面列举了一些常见的二进制位的变换操作。

   功能              |           示例            |    位运算
---|---|---
去掉最后一位          | (101101->10110)           | x shr 1
在最后加一个0         | (101101->1011010)         | x shl 1
在最后加一个1         | (101101->1011011)         | x shl 1+1
把最后一位变成1       | (101100->101101)          | x or 1
把最后一位变成0       | (101101->101100)          | x or 1-1
最后一位取反          | (101101->101100)          | x xor 1
把右数第k位变成1      | (101001->101101,k=3)      | x or (1 shl (k-1))
把右数第k位变成0      | (101101->101001,k=3)      | x and not (1 shl (k-1))
右数第k位取反         | (101001->101101,k=3)      | x xor (1 shl (k-1))
取末三位              | (1101101->101)            | x and 7
取末k位               | (1101101->1101,k=5)       | x and (1 shl k-1)
取右数第k位           | (1101101->1,k=4)          | x shr (k-1) and 1
把末k位变成1          | (101001->101111,k=4)      | x or (1 shl k-1)
末k位取反             | (101001->100110,k=4)      | x xor (1 shl k-1)
把右边连续的1变成0    | (100101111->100100000)    | x and (x+1)
把右起第一个0变成1    | (100101111->100111111)    | x or (x+1)
把右边连续的0变成1    | (11011000->11011111)      | x or (x-1)
取右边连续的1         | (100101111->1111)         | (x xor (x+1)) shr 1
去掉右起第一个1的左边 | (100101000->1000)         | x and (x xor (x-1))

c语言中运算符优先级
<table>
	<tr>
    	<th> 优先级 </th>
        <th> 符号 </th>
    </tr>
    <tr>
    	<th> 1 </th>
        <th>  ~ </th>
    </tr>
    <tr>
    	<th> 2 </th>
        <th>  <<, >> </th>
    </tr>
    <tr>
    	<th> 3 </th>
        <th> & </th>
    </tr>
    <tr>
    	<th> 4 </th>
        <th> ^ </th>
    </tr>
    <tr>
    	<th> 5 </th>
        <th> | </th>
    </tr>
    <tr>
    	<th> 6 </th>
        <th> &=、^=、|=、<<=、>>= </th>
    </tr>
</table>


最后这一个在树状数组中会用到。

Pascal和C中的16进制表示

    Pascal中需要在16进制数前加$符号表示，C中需要在前面加0x来表示。这个以后我们会经常用到。

整数类型的储存

    我们前面所说的位运算都没有涉及负数，都假设这些运算是在unsigned/word类型（只能表示正数的整型）上进行操作。但计算机如何处理有正负符号的整数类型呢？下面两个程序都是考察16位整数的储存方式（只是语言不同）。
		var
		   a,b:integer;
		begin
		   a:=$0000;
		   b:=$0001;
		   write(a,' ',b,' ');
		   a:=$FFFE;
		   b:=$FFFF;
		   write(a,' ',b,' ');
		   a:=$7FFF;
		   b:=$8000;
		   writeln(a,' ',b);
		end.

		#include <stdio.h>
		int main()
		{
		    short int a, b;
		    a = 0x0000;
		    b = 0x0001;
		    printf( "%d %d ", a, b );
		    a = 0xFFFE;
		    b = 0xFFFF;
		    printf( "%d %d ", a, b );
		    a = 0x7FFF;
		    b = 0x8000;
		    printf( "%d %dn", a, b );
		    return 0;
		}
	
		两个程序的输出均为0 1 -2 -1 32767 -32768。其中前两个数是内存值最小的时候，中间两个数则是内存值最大的时候，最后输出的两个数是正数与负数的分界处。由此你可以清楚地看到计算机是如何储存一个整数的：
        计算机用$0000到$7FFF依次表示0到32767的数，剩下的$8000到$FFFF依次表示-32768到-1的数。32位有符号整数的储存方式也是类似的。稍加注意你会发现，二进制的第一位是用来表示正负号的，0表示正，1表示负。
        这里有一个问题：0本来既不是正数，也不是负数，但它占用了$0000的位置，因此有符号的整数类型范围中正数个数比负数少一个。对一个有符号的数进行not运算后，最高位的变化将导致正负颠倒，并且数的绝对值会差1。也就是说，not a实际上等于-a-1。这种整数储存方式叫做“补码”。

11101
10010

10011
