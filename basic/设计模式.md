### 设计模式

#### 简介

1. GOF(四人帮)设计原则

   1. 对接口编程而不是对实现编程
   2. 优先使用对象组合而不是继承
   3. 封装变化

2. 六大原则

   1. 开闭原则（open close principle）

      1. 对扩展开放，对修改关闭

   2. 里氏代换原则（Liskov Substitution Principle）

      1. 任何基类可以出现的地方，子类一定可以出现
      2. 使用继承复用的基础

   3. 依赖倒转原则（Dependence lnversion Principle）

      1. 针对接口编程，依赖于抽象而不依赖具体

   4. 接口隔离原则（Interface Segregation Principle）

      1. 使用多个隔离的接口优于使用单个接口
      2. 降低类之间的耦合度

   5. 单一职责原则（Demeter Principle）

      1. 一个实体应当尽量少的与其他实体之间发生相互作用，是系统功能相对独立
      2. 也叫依赖单一原则，尽可能一个类只有一个因素会引起变化

   6. 合成复用原则（Composite Reuse Principle）

      1. 尽量使用合成/聚合的方式，而不是使用继承
      2. 如果父类发生了改变，那么子类也要发生相应的改变，这就直接导致了类与类之间的高耦合





## 深入浅出设计模式

> 设计模式
>
> 策略模式/依赖注入/工厂模式等都可以使用反射进行简化，让它更符合OPC原则

### 1 简单工厂模式

> 通过一个工厂函数，通过if--else 判断创建不同的对象

### 2 策略模式

> 定义了不同模块（行为和算法），分别封装起来，让他们之间可以互相替换，此模式可以让对象的行为可以变化（切换不同的模块）而不影响到其他功能
>
> 可以通过interface对象实现

> 1. 把会变化的部分取出并“封装”起来，好让其他部分不会受到影响
>    1. 找出应用中可能需要变化之处，把他们独立出来，不要和哪些不需要变化的代码混在一起
>    2. 针对接口编程，而不是针对实现编程
>    3. 将可能公用的动作抽取出来，需要调用时，使用一个变量字段保存响应动作函数实现
>    4. 动态的设定行为（类行为），通过变量保存某些对象的动作，再通过函数允许对其进行设置。
> 2. 多用组合，少用继承
>    1. 继承的问题在于，后续使用维护过程中，不够灵活
>    2. 多用组合接口动作的方式，可以在使用中灵活的调整对象的动作

### 3. 依赖注入

> 优点：
>
> 1. 代码松耦合，灵活的应变需求变更
> 2. 如果要测试，需要深入到依赖的方法中才能完成测试动作，而不是专注于需要测试的对象
>
> 缺点：
>
> 1. 依赖于反射实现，会影响性能
>
> 其实就是让某个对象的依赖从一个具体的对象变为一个抽象类型，有点像装饰器
>
> 然后从构造函数中传入这个抽象类型实现对象的初始化，这样子可以实现代码的解耦
>
> 对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它
>
> k依赖自身还将会有依赖，依赖中又有依赖，如果是这样一个极其复杂的依赖关系图（DependencyGraph）
>
> 两种方式：
>
>  	1. 主动注入：
>       ​	1. setter注入
>       ​	2. 构造器注入
> 	2. 被动注入，使用独立注入器，在需要的时候调用注入器完成注入
>         	1. 可以使用反射模式，实现注入器的解耦

### 4. 三层架构

> 1. 界面层
> 2. 数据访问层
> 3. 业务逻辑层
>
> 注意：这是指代码逻辑上的分层，不是硬件上的分层，也不是指MVC之类的分离分层

### 5 单例模式

> 涉及到一个单一的类，确保这个类只有一个对象会被创建

### 6. 抽象工厂模式

> 创建一个工厂接口，通过分别实现工厂接口，然后用抽象类对象来创建不同的类

### 7. 建造者模式

>主要是用于一系列对象的集中生成，套餐的概念
>
>

### 8. 原型模式

> 用于创建重复的对象，同时保证了性能
>
> 实现一个原型，以后的创建使用一个该对象的副本

### 9. 适配器模式

> 适用于将一个现存的对象放入一个新的环境，新环境本身不兼容这个对象，通过一个新类进行转接（像变压器）

### 10. 桥接模式

> 对接两个不兼容的对象，作为转换器

### 11. 工厂模式

> 为每个类分别创建一个工厂类，相较于简单工厂模式，具有更高的开放性，符合开放原则
>
> 三种工厂模式的优势：
>
> 1. 将类的实例化单独抽离出来，实现了代码复用，也方便代码迭代
> 2. 简化了类的调用，调用其他类时，不需要关注细节，调用工厂函数即可
>
> 适用于类涉及的子类较多，很容易发生改变，初始化工作比较复杂的类

