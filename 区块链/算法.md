# 算法

> 衡量一个算法：
>
> 1. 时间复杂度
>    1. 算法执行时间与代码规模之间的线性关系
> 2. 空间复杂度
>    1. 空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度
>
> 使用算法：
>
> 1. 算法比较快
> 2. 使用较少的内存
> 3. 更容易编写程序
> 4. 更适合以后的场景
> 5. 算法比较通用
>
> 冯诺依曼体系：将程序本身当作数据对待，以同样的方式存储，要点就是：计算机数制采用二进制，计算机按照程序的顺序执行
>
> 属性：
>
> 1. 有效性
> 2. 准确性
> 3. 终止性
> 4. 高效性
> 5. 程序复杂性
>
> 素数：因数只有1和它本身
>
> 一个二进制数x的开方y，位数接近于x的一半

## 牛顿法开平方

> z = 1/2 ( z + x/z ) = z/2  + (x/(z^2))z/2   // 可以看到x  与 z * z对比，会向正确值收敛    
>
> x是被开平方的数，z是一个近似值，通过初始化一个z，然后判断abs(x-z)  进行循环，每一个循环z就更接近z的开平方值

## 暴力穷举搜索

> 穷举所有可能性，寻找答案

## 贪婪算法

> 解决一个问题，每一步都是选择代价最小的可能性，即使后续可能会有更大的代价

## 动态规划

> 基于解决有限子问题的策略，保存子问题的结构，然后在解决主问题的时候可以重复使用这些子问题的结果

## 1. 查找算法

### 1.1 顺序查找

> 从尾到头，逐个遍历查找，又叫线性查找

### 1.2 二分查找法

> 又称折半查找
>
> 需要将带查找列表排序后，折半查询

## 2. 排序算法

> 稳定指，如果列表中有数值相等的元素，其顺序是一致的

### 2.1 冒泡排序（稳定）

> 对n个元素进行n-1次遍历，每次遍历从头开始位置，依次往后比较前后相邻元素，将较大的元素往后移
>
> 如果某次遍历没有发生交换动作，则不需要继续进行遍历，因为已经有序了

### 2.2 简单选择排序

> 对n个元素进行n-1次遍历，第i次选择，则从 n - i + 1 : n-1 的元素范围中选出最小的，交换到序列的位置i-1 的元素
>
> 就是说，冒泡排序是每次遍历时，从后往前递增忽略
>
> 简单选择排序时，从前往后忽略

### 2.3 直接插入排序（稳定）

> 对有n个元素的序列，从idx为1开始逐个获取，每次获取后，同小于idx的子序列中元素进行对比，找到合适的位置，就插入其中，然后继续向后读取原始队列
>
> 较为低效
>
>

### 2.4 希尔排序

> 又叫最小增量排序，是对直接插入排序的优化，优化在于分组排序后，后面的排序节省了很多交换操作，判断操作资源消耗较少
>
> 其实希尔排序就是先把一个整体分成无数个单元片段，根据步长，然后对这些单元进行排序，达到间断性有序的效果，最后在进行整体的插入排序
>
> 分而治之，分组后对每个分组进行排序
>
> 三层循环：
>
> 1. 第一层循环判断步长大于等于1，每次循环结束，使用 step = step/n    进行步长缩短 
> 2. 第二层循环，以步长为上限，对每个分组进行操作，
> 3. 第三层循环依次对分组内元素进行判断
>
> ```
> func Xier(lst []int) {
> 	// foot step
> 	h := 1   //  设定步长
> 
> 	for h < len(lst)/3{
> 		h =  3 * h  + 1    // 设定步长，这里每个子集元素为3
> 	}
> 
> 	for h >= 1 {
> 		for i := 0 ;i < h ; i++ {
> 			for j:=i; j + h< len(lst);j += h{
> 				if (lst[j] > lst[j + h]) {
> 					Swap(lst, j, j+h)
> 				}
> 			}
> 		}
> 		h = h/2    // 每一轮迭代完成，缩小步长
> 	}
> }
> ```
>
>

### 2.5 归并排序

> 彻底的分而治之思维，将待排序序列分为两部分，对每部分递归地应用归并排序，在两部分都排好序后进行合并。
>
> ```
> func Guibing(lst []int) []int {
> 	if len(lst) > 2{     // 
> 		llst := lst[:len(lst)/2]
> 		llst=Guibing(llst)
> 		rlst := lst[len(lst)/2:]
> 		rlst = Guibing(rlst)
> 		lst = append(llst, rlst...)
> 		fmt.Println(lst)
> 		Xier(lst)
> 		fmt.Println(lst)
> 	} else if len(lst)==2{
> 		if lst[0] > lst[1]{
> 			Swap(lst, 0, 1)
> 		}
> 	}
> 	return lst
> }
> ```
>
>

### 2.6 快速排序（稳定  ）

> 快速排序：在待排序的序列中选择一个称为主元的元素，将数组分为两部分，使得第一部分中的所有元素都小于或等于主元，而第二部分中的所有元素都大于主元，然后对两部分递归地应用快速排序算法。
>
> ```
> func Quick(lst []int)[]int  {
> 	if len(lst) > 1{
> 		Tag := lst[0]    // 一般将第一个元素设为主元
> 		llst := []int{}
> 		rlst := []int{}
> 		for i := 1;i< len(lst) ;i++{
> 			if lst[i] < Tag{
> 				llst = append(llst, lst[i])
> 			} else {
> 				rlst = append(rlst, lst[i])
> 			}
> 		}
> 		llst = Quick(llst)      // 只能通过递归
> 		rlst = Quick(rlst)
> 		lst = append(llst, Tag)
> 		lst = append(lst, rlst...)
> 	}
> 	return lst
> }
> ```
>
>

### 2.7 堆排序

> n个关键字序列K1，K2，…，Kn称为堆，当且仅当该序列满足如下性质（简称为堆性质）：		
>
> 1. 小根堆： ki <= k(2i）且 ki <= k(2i+1) (1 ≤ i≤ n/2）
> 2. 大根堆则换成>=号。
>
> 可以将其看作一个完美二叉树，意思就是，小根堆每一个根节点都比其子节点要大，二叉树顶端是最小元素
>
> 堆排序的交换次数比快排要多好多，所以需要完整的排序时，快排比较合适
>
> 堆排序主要用途：
>
> 1. 获取序列中的topN
> 2. 优先级队列
>
> 要从最后一个非叶子节点开始

```
func HeapFunc(lst []int) {
	for i:=0;i< len(lst);i++{
		Build(lst[i:])
	}
}

func Build(lst []int)  {
	i := len(lst)/ 2      // 因为slice的索引起始是0， 所以子节点idx是 2*i +1 /2 *i+2
	for j:=i;j >=0;j--{    // 注意这里必须从最后一个非叶子节点开始，从顶端开始的话，无法获得正确的堆
		if  j * 2 + 1 < len(lst)&&lst[j] > lst[j * 2 + 1] {
			lst[j], lst[j * 2 + 1] = lst[j * 2 + 1], lst[j]
		}
		if j * 2 + 2 < len(lst) && lst[j] > lst[j * 2 + 2]{
			lst[j], lst[j * 2 + 2] = lst[j * 2 + 2], lst[j]
		}

	}
	fmt.Println(lst)
}
```

