## 比特币

### 1. 手记

1. 比特币是种数据结构，容量有限（目前每个区块1m，大约存储4200条交易，每秒约处理7比左右）
2. 基于hash的向左的单向链表结构
3. 记账权基于hash碰撞（通过调整匹配位数，调整难度），通过计算寻找满足特定SHA-256哈希值对应的数值解
4. 使用levelDB作为底层数据存储

#### 1.1 区块（block)

> 区块链的基本结构单元
>
> 两部分组成：
>
> 1. 包含元数据的区块头
>
>    			2. 包含交易数据的区块主体构成
>
> 区块中不保存本区块的hash值，比特币中维护两个数据库：
>
> 1. 区块数据
> 2. 区块数据同hash之间的映射关系（本区块的hash在节点接收到区块时，计算得到，然后保存到对应关系库中）
>
> 区块的hash指的是对区块头进行hash运算，不是整个区块体。

##### 1.1 1 区块头（分为三部分）

 1. 用于连接父级区块的hash值

 2. 挖矿难度、Nonce(随机数，用于POW算法的计数器），时间戳

 3. 能够总结并快速归纳校验区块中所有交易数据的merkle（默克尔）树根数据

    [默克尔树参考![merkle树结构](H:\go\markdown\区块链\img\merkle树结构.png)](https://blog.csdn.net/weixin_37504041/article/details/80474636)

##### 1.1.2 区块体

1. 区块体中是二叉树结构的默克尔树
2. 所以交易数必须为偶数，如果不是，则会将最后一个交易复制一份，然后生成
3. Merkle树的叶子节点存储的是数据信息的哈希值，非叶子的节点存储的是对其下面所有叶子节点的组合进行哈希计算后的出的哈希值
4. 区块两种有两种交易：
   1. 挖矿交易（永远在区块体中的第一条记录）
   2. 其他交易

##### 1.1.3 加密算法

​	区块链中，通常使用SHA-256(安全散列算法)进行区块加密

##### 1.1.4 公钥和私钥

 	1. 比特币系统中，私钥本质上是32个字节组成的数组，公钥和地址的生成都依赖私钥。
 	2. 私钥花费比特币的方式：使用私钥对未花费的交易进行签名
 	3. 比特币中使用椭圆曲线算法（ECC）

##### 1.1.5 时间戳

> 区块链中的时间错从区块生成的一刻起就存在于区块中了

#### 1.2 节点（node）

> 每个运行软件的实体成为一个节点
>
> 比特币中没有私钥--余额表单，发起的交易检验时，需要遍历整个账本（这效率。。。）

* 轻节点（只下载block头部和与自己相关的交易记录）
* 全节点（下载全部block）

#### 1.3 POW(工作量证明) -- 别名：挖矿

* POW：Proof of Work

* 每个block的数据都不完全一样

* 大概十分钟新生成一个block

* 有人挖矿成功，则同步新的账本，将其中已处理的交易剔除后生成新的block，参与下一次竞争。

* 对当前打包好的交易进行哈希SHA256运算，然后进行碰撞

  > SHA256(区块数据 + 随即数据) < 目标的哈希值
  >
  > 目标哈希值 由n个前导零和一串十六进制数组成（整体由难度系数）


#### 1.4 分叉

##### 1.4.1 软分叉

 	1. 软分叉是暂时的
 	2. 当新的共识规则发布后，没有升级的节点由于不了解新的机制，生成一些“不合格”的区块
 	3. 宏观上，并没有分叉，新旧版本的区块存在于一个链条之上，互相之间可确认。
 	4. 相当长的时间内，允许旧版本不升级，新旧版区块共存。

##### 1.4.2 硬分叉

 	1. 硬分叉是永久性分歧
 	2. 分为了新链和旧链
 	3. 硬分叉是指比特币的区块格式或交易格式（共识）发生改变时，未升级的节点拒绝验证已经升级的节点生产出的区块，已升级的节点则可以验证未升级节点生产出的区块
 	4. 以太坊2016.7 执行了硬分叉，一条ETC(原链)，另一条ETH(分叉链)



#### 1.5 交易流程

1. 创建交易

   1. 创建交易时遍历账本
   2. 提供一个解锁（输入）脚本/锁定（输出）脚本，矿工使用这两个脚本校验交易
      1. 解锁脚本中包含签名/公钥，对输入中的交易进行解锁才能使用其中的币
         1. 签名：对引用的交易ID进行了签名
         2. 交易时交易内容的hash
         3. 每个引用都有一个解锁脚本
      2. 锁定脚本中使用
   3. UTXO(unspent transaction output, 未花费的余额)
      1. UTXO没有一个专门字段存储，是遍历帐本后的一个展示
      2. UTXO只能一次花完，找零就是生成一个更小的UTXO
      3. 比特币余额：就是扫描整个链，聚合所有属于用户的UTXO
      4. 比特币为了优化交易，会将所有的UTXO（chainstate目录中内容）存储到全节点的内存中，称为utxo账本/UTXO池
      5. 比特币网络监测着以百万为单位的所有可用的（未花费的）UTXO。当一个用户接收比特币时，金额被当作UTXO记录到区块链里。这样，一个用户的比特币会被当作UTXO分散到数百个交易和数百个区块中。
      6. 交易的单个输出是UTXO的最小单元
   4. 交易输入
      1. 引用UTXO的交易ID
      2. UTXO   交易的索引（具体位置）
      3. 解锁脚本（签名/公钥）
   5. 交易输出
      1. 接收金额
      2. 锁定脚本（对方公钥hash,其实是通过地址值获取的一个片段）

2. 广播交易（验证交易）

   > 广播交易信息和接收交易信息对节点来说是同步进行的，每收到一条广播信息，就会进行校验，如果有效，则继续向外扩散

   1. 校验过程
      1. 使用解锁脚本对交易的输出进行校验
         1. 使用公钥校验输入的交易是否属于自己
         2. 使用签名，验证其身份

3. 挖矿竞争

4. 胜出，广播结果

5. 记账，获取奖励，广播账本

6. 同步账本，新一轮竞争

#### 1.6 比特币地址

> 比特币中每次交易都会生成一个新的地址（因为比特币的整个交易流程都可追溯，可上溯至打包奖励的区块）
>
> 比特币地址生成过程
>
> 私钥 —> 公钥 --> 地址值

1. 对公钥进行SHA256计算（取20位）
2. version + 第一步的20位  （21位）
3. 对这21位 进行SHA256计算（取4位）
4. 第二步/第三步  拼接25位数据，这就是地址值（25位）

5. 使用base58 进行编码
   1. base58 在base64基础上删掉六个字符（0(零), O(大写o), +, /, l(小写L), I(大写i)）

#### 1.7 找零机制

> 比特币中没有账户，余额之类的概念
>
> 所有的信息都保存在帐本中，每次交易都会遍历相关的交易（遍历到币值够交易使用为止，额度大于等于交易所需，有找零机制）
>
> 每一个交易的输入都是上一个交易的输出
>
> 输入/输出都可以是多个
>
> 每个交易的币值都是原子性的，所以每次转账时，都会将输出交易中的币全部使用，所以有了特殊的找零机制，这是因为每次转入交易获得的币都有一个（以使用/未使用）的属性。

1. 比特币区块可以进行修改
2. 比特币的找零机制是，创建一个支付交易的同时，将剩余币值转给自己



### 2. 区块链

> 区块链实质上就是一个分布式账本
>
> 一种去中心化的信任体系
>
> 发展经历了三个阶段：
>
> 可编程货币（1.0）--> 可编程金融 --> 可编程社会
>
> 区块链技术，应该在公平和效率之间寻求一个合适的平衡点

####  2.1 概念

> 区块链（BlockChain)是一个由不同节点共同参与的分布式数据库系统，是开放式的账簿系统（ledger）；它是由一串按照密码学方法产生的数据块或数据包组成，即区块（block），对每一个区块数据信息都自动加盖时间戳，从而计算出一个数据加密数值，即哈希值（hash）。每一个区块都包含上一个区块的哈希值，从创始区块（genesis block）开始链接（chain）到当前区域，从而形成区块链。

#### 2.2 特点

1. 去中心化（不赞同完全去中心化）
   1. 单账本损坏，仍然可以保证数据安全
   2. 依赖于p2p网络的自组网特性，实现数据传输
   3. 区块链的核心应该是分布式而不是去中心，应该是种若中心化的系统
   4. 去中心应该是个过程而不是结果。
2. 去信任
   1. 无需信用背书，进行交易
   2. 整个系统运转完全透明，在规则内，节点之间无法互相欺骗
3. 集体维护
4. 可靠的数据库
   1. 强调不可篡改
   2. 区块链是分布式账本，分布式账本不一定是区块链
5. 智能合约
   1. 代码即法律---只能是中乌托邦理想，智能合约只是帮助执行双方约定条件的程序

#### 2.3 模型框架

> 有争议
>
> 较通用的基础架构分为六层：
>
> ​	数据层，网络层，共识层，激励曾，合约层，应用层

![区块链基础架构](H:\go\markdown\区块链\img\区块链基础架构.png)

##### 2.3.1 数据层

1. 区块链技术的物理层面

##### 2.3.2 网络层

1. 网络层的主要目的是实现区块链网络中节点之间的信息交流
2. 本质上依赖于P2P网络，每个节点既可以接受信息，也可以产生信息
3. 网络中，每个节点都可以产生区块，新区块生成后以广播的形式通知其他节点，其他节点会对这个区块进行验证，当全区块链网络中超过51%用户验证通过，则添加至主链

##### 2.3.3 共识层

> 让高度分散的节点在去中心化的系统中高效的针对区块数据的有效性达成共识
>
> 决定哪个区块可被添加到区块链中，同时明确当前状态

1. 工作量证明
2. 权益证明
3. 股份授权证明

##### 2.3.4 激励层

1. 记账权奖励
2. 手续费

##### 2.3.5 合约层

1. 各种脚本代码、算法机制以及智能合约等
2. 规定了交易方式和过程中涉及的钟中细节

##### 2.3.6 应用层

1. 区块链的应用场景

### 2.4 区块链基本类型

#### 2.4.1 公有链

>  公网之上，所有人都可以作为节点

##### 2.4.1.1 公有链特点

1. 保护用户免受开发者影响
2. 访问门槛低
3. 所有数据默认公开

#### 2.4.2 私有链

> 写入权限仅在一个组织手里
>
> 目的是对读取权限或者对外开放权限进行限制

##### 2.4.3.1 特点

1. 相较于公有链，交易速度非常快
2. 为隐私提供更好的保障
3. 交易成本低（基本不需要手续费）
4. 保护原有产品生态

#### 2.4.3 联盟链

> 共识过程受到预选节点控制的区块链
>
> 一种部分去中心化的形式
>
> 共识需要半数以上节点认同





### 2.5 共识机制

#### 2.5.1 类两军问题

> 双方交互时：反复确认，没完没了

#### 2.5.2 拜占庭将军问题

> 多方互信的问题（收到的信息能否真实反馈放送方的意图，是否被篡改）
>
> 不确定哪一方的数据是真实的



#### 2.5.3 工作量证明（proof of work POW）

> 只能从结果证明，监测过程工作量过于低效繁琐

##### 2.5.3.1 应用

1. 比特币区块生成过程使用了POW机制，以太坊前三阶段使用了POW
2. 一个符合要求的区块哈希值由N个前导零构成，零的个数取决于网络的难度值
3. 依赖机器进行数学运算获取记账权

##### 2.5.3.2 优势

1. 共识机制高
2. 完全去中心化
3. 节点自由进出
4. 容错率高，允许50%的节点出错

##### 2.5.3.3 劣势

1. 资源消耗大
2. 可监管性差
3. 性能效率低（每次都需要全网参与），共识达成周期长
4. 促使矿池的产生，是的去中心化弱化了

#### 2.5.4 权益证明（Proof of Stake POS）

> 理念：节点记账权的获得难度与节点持有的权益成反比
>
> ​	根据每个节点所占代币的比例和时间，等比例地降低挖矿难度，加快了计算速度
>
> ​	有两种说法，一种依然基于哈希运算，竞争获取记账权。另一种是根据缴纳代币保证金的比例，随机选择下一个认证者
>
> ​	可监管性差。
>
> ​	依然是以最长链为准

##### 2.5.4.1 币龄

1. 币龄可以简单理解为币值 * 时间，持币越久，币龄越大
2. 纯粹pos机制基于币龄发放收益（相当于分红，IPO模式）
3. 会有一种问题：大户收益越来越多，散户收益越来越少（比重）
4. 通常采用一种pow + pos 混合机制
5. 一旦获取了记账权，币龄清零

##### 2.5.4.2 优势

1. 降低了能耗，加快了计算速度

##### 2.5.4.3 劣势

1. 可监管性差
2. 还是需要挖矿（商用的障碍）
3. 所有的确认都只是一个概率上的表达，而不是一个确定性事实，可能被攻击。
4. 恶意验证者缺乏惩罚机制，在主链和支链都进行投注，不管怎样，总可以获得收益，不会失去利益。
5. 开发者很容易获取大量代币，价值难以保障
6. 被选中的代理人可能不想进行认证（未开机之类），可以通过选定一个节点集合，一定时间内不生成区块，则换下一个。

#### 2.5.5 股份授权证明（Delegates Proof of Stake DPoS)

> 选举若干代理人，由代理人验证和记账
>
> 合规监管/性能/资源消耗和容错性与PoS相似
>
> 这是比特股（BTS）最先引入的。比特股首次提出了去中心化自治公司(DACs)的理念。比特股的目的就是用于发布DACs。这些无人控制的公司发行股份，产生利润，并将利润分配给股东。实现这一切不需要信任任何人，因为每件事都是被硬编码到软件中的。通俗点讲就是：比特股创造可以盈利的公司（股份制），股东持有这些公司的股份，公司为股东产生回报。无需挖矿。

##### 2.5.5.1 优势

1. 大幅缩小参与验证和记账节点的数量，可以达到秒级（因为代理人数量有限，所以效率较高）
2. 被选举出的代理人，权益完全对等，无法通过1%的投票权作恶，利用在一定程度上抵抗攻击
3. 相对于POW现在的矿池，去中心化更彻底一些

##### 2.5.5.2 劣势

1. 共识机制还是依赖于代币，商用障碍
2. 拥有者的投票积极性一般来说并不高，所以~
3. 对坏节点的清理较为困难

#### 2.5.6 投注公式（Casper 鬼马小精灵）

> 属于一种POW协议的POS变种，是以太坊的下一代共识机制
>
> Casper的共识是按区块达成的，PoS是按链达成的
>
> 只有在验证人当前已缴纳保证金的情况下他的签名才有意义
>
> Casper拥有惩罚机制，非法节点通过恶意攻击网络会被没收保证金

#### 2.5.6.1 验证人需要完成两个动作

1. 出块
   1. 轮到他们出块时，就制造一个区块，并签名发送至网络
2. 投注
   1. 向认为被最终确认的块投注，当该块被确认后，可以获取相应比例的奖励，如果未被确认，只能回收部分保证金
   2. 经过多轮投注，投注比例会收敛出一个胜率较高的区块
   3. 如果锁定保证金比例较高的一部分验证人投注较高的胜率（> 99.9%）的区块则最终确认

##### 2.5.6.2 优势

1. 相较于POW共识，出块速度较快，能耗较少
2. 相较于POS共识，增加了恶意攻击者需要付出的代价

##### 2.5.6.3 劣势

1. 以太坊的下一代共识机制，还在摸索阶段


#### 2.5.7 瑞波共识机制

> 基于特殊节点列表形成共识
>
> 初始特殊节点列表在，要接纳一个新成员，必须由该列表51%的成员投票通过
>
> 共识遵循这些核心成员的“51%权力”，列表外的节点则没有影响能力
>
> 相较于其他共识机制更加中心化，如果中心列表节点开始“腐败”，其他节点无能为力

#### 2.5.8 pool（联营）验证池

> 基于传统的分布式一致性技术以及数据验证机制，

##### 2.5.8.1 优点

1. 不需要代币也可以工作
2. 在成熟的分布式一致性算法（Pasox、Raft）的基础上，实现秒级共识验证

##### 2.5.8.2 缺点

1. 去中心化程度不如比特币



#### 2.5.8 实用拜占庭容错

> 节点之间交互了错误的数据而无法达成共识
>
> 拜占庭将军问题的解决方法：N >= 3F + 1(N: 节点总数，F:有问题的节点总数)，就是说只要系统中有2/3的节点正常工作，就可以保证一致性
>
> 采用的是“许可投票，少数服从多数”选举领导者并进行记账



#### 2.5.9 授权拜占庭容错

> 实用拜占庭容错的优化版本，以适用于区块链
>
>

#### 2.5.10 帕克索斯算法

> 传统的分布式一致性算法，是一种基于选举领导者的共识机制。
>
> 领导节点拥有绝对权限，并允许强监管节点参与，性能高，资源消耗低
>
> 选举过程不允许有作恶节点，不具备容错性

### 2.6 数字资产

> 比数字货币范围更大、价值更大的是数字资产。
>
> 数字资产：区块链上登记、发行、交易的资产。往往以数字代币的方式记录在分布式账本上。以数字代币（token)的方式记录在分布式账本上
>
>





## 3 那些人那些事

### 3.1 中本聪

> 技术整合者
>
> 神秘人



