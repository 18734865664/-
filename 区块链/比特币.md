## 比特币

### 1. 手记

1. 比特币是种数据结构，容量有限（目前每个区块1m，大约存储4200条交易，每秒约处理7比左右）
2. 基于hash的向左的单向链表结构
3. 记账权基于hash碰撞（通过调整匹配位数，调整难度），通过计算寻找满足特定SHA-256哈希值对应的数值解
4. 使用levelDB作为底层数据存储
5. 因为每笔交易都在公众面前，所以追踪一笔比特币交易比追踪人名币方便的多
6. 每21w个区块，奖励减少一半
7. 从中本村的初衷看，将比特币类比做贵金属，是希望像贵金属一样，随着用户的热动变化，其本身价值变动，比特币本身数量不变（以期达到抗通胀的作用），这其实就是把比特币定位到了收藏品的位置，而不是一种交易流通介质。所以，现在比特币的流通性并不强
8. 对中本村来说，比特币系统更像一个社会实验，走到今天完全是意外

#### 1.1 区块（block)

> 区块链的基本结构单元，初衷是用于性能优化（将每个交易都单独进行共识操作，系统效率很低，hash链条也过长）
>
> 两部分组成：
>
> 1. 包含元数据的区块头
>
>    			2. 包含交易数据的区块主体构成
>
> 区块中不保存本区块的hash值，比特币中维护两个数据库：
>
> 1. 区块数据
> 2. 区块数据同hash之间的映射关系（本区块的hash在节点接收到区块时，计算得到，然后保存到对应关系库中）
>
> 区块的hash指的是对区块头进行hash运算，不是整个区块体。
>
> 区块链技术结合了两种基于哈希的数据结构
>
>  	1. 哈希链：哈希区块头部，将区块形成链条，区块头是挖矿过程中唯一哈希值化的，验证区块链，检查头部就够了
>  	2. merkle根：将大量交易组织起来放入区块，区块头中包含了merkle_root值，校验了头部数据，就可以证明交易未被篡改
>
> 孤块：不在主链中的区块，被称为孤块，形成原因较多
>
>  	1. 区块中包含不正当的交易/或者试图双重支付
>  	2. 网络延迟：两个矿工几乎同时完成了POW，也近乎同时被广播到网络中

##### 1.1 1 区块头（分为三部分）

 1. 用于连接父级区块的hash值，

 2. 挖矿难度、Nonce(随机数，用于POW算法的计数器），时间戳

 3. 能够总结并快速归纳校验区块中所有交易数据的merkle（默克尔）树根数据

    [默克尔树参考![merkle树结构](H:\go\markdown\区块链\img\merkle树结构.png)](https://blog.csdn.net/weixin_37504041/article/details/80474636)

##### 1.1.2 区块体

1. 区块体中是二叉树结构的默克尔树
2. 所以交易数必须为偶数，如果不是，则会将最后一个交易复制一份，然后生成
3. Merkle树的叶子节点存储的是数据信息的哈希值，非叶子的节点存储的是对其下面所有叶子节点的组合进行哈希计算后的出的哈希值
4. 区块两种有两种交易：
   1. 挖矿交易（永远在区块体中的第一条记录）
   2. 其他交易

##### 1.1.3 加密算法

​	区块链中，通常使用SHA-256(安全散列算法)进行区块加密

##### 1.1.4 公钥和私钥

   	1. 比特币系统中，私钥本质上是32个字节组成的数组，公钥和地址的生成都依赖私钥。
   	2. 私钥花费比特币的方式：使用私钥对未花费的交易进行签名
   	3. 比特币中使用椭圆曲线算法（ECC）

##### 1.1.5 时间戳

> 区块链中的时间错从区块生成的一刻起就存在于区块中了

#### 1.2 节点（node）

> 每个运行软件的实体成为一个节点
>
> 比特币中没有私钥--余额表单，发起的交易检验时，需要遍历整个账本（这效率。。。）

* 轻节点（只下载block头部和与自己相关的交易记录）
* 全节点（下载全部block）

#### 1.3 POW(工作量证明) -- 别名：挖矿

* POW：Proof of Work

* 每个block的数据都不完全一样

* 大概十分钟新生成一个block

* 有人挖矿成功，则同步新的账本，将其中已处理的交易剔除后生成新的block，参与下一次竞争。

* 对当前打包好的交易进行哈希SHA256运算，然后进行碰撞

  > SHA256(区块数据 + 随即数据) < 目标的哈希值
  >
  > 目标哈希值 由n个前导零和一串十六进制数组成（整体由难度系数）
  >
  > 目前pow的难度系数，每2016个区块调整一次（两周）
  >
  > 当试完了全部可能仍然没有找到合适的nonce，则改变下币基交易中的数据，重新尝试

* POW意味着持续的能源消耗，现在社区对是否将比特区技术的共识机制进行调整，有分歧


#### 1.4 分叉

##### 1.4.1 软分叉

 	1. 软分叉是暂时的
 	2. 当新的共识规则发布后，没有升级的节点由于不了解新的机制，生成一些“不合格”的区块，这些节点有可能无法通过新版本节点的校验，造成临时的软分叉
 	3. 宏观上，并没有分叉，新旧版本的区块存在于一个链条之上，互相之间可确认。
 	4. 相当长的时间内，允许旧版本不升级，新旧版区块共存。

##### 1.4.2 硬分叉

 	1. 硬分叉是永久性分歧
 	2. 分为了新链和旧链
 	3. 硬分叉是指比特币的区块格式或交易格式（共识）发生改变时，未升级的节点拒绝验证已经升级的节点生产出的区块，已升级的节点则可以验证未升级节点生产出的区块
 	4. 以太坊2016.7 执行了硬分叉，一条ETC(原链)，另一条ETH(分叉链)



#### 1.5 交易流程

> 比特币交易，是旧币销毁，等值新币生成的过程
>
> 每个币都可以被说有人看到，用以防止双花问题

1. 创建交易

   1. 创建交易时遍历账本
   2. 提供一个解锁（输入）脚本/锁定（输出）脚本，矿工使用这两个脚本校验交易
      1. 解锁脚本中包含签名/公钥，对输入中的交易进行解锁才能使用其中的币
         1. 签名：对引用的交易ID进行了签名
         2. 交易时交易内容的hash
         3. 每个引用都有一个解锁脚本
      2. 锁定脚本中使用
   3. UTXO(unspent transaction output, 未花费的余额)
      1. UTXO没有一个专门字段存储，是遍历帐本后的一个展示(一般存储于内存中，用于快速执行交易校验)
      2. UTXO只能一次花完，找零就是生成一个更小的UTXO
      3. 比特币余额：就是扫描整个链，聚合所有属于用户的UTXO
      4. 比特币为了优化交易，会将所有的UTXO（chainstate目录中内容）存储到全节点的内存中，称为utxo账本/UTXO池
      5. 比特币网络监测着以百万为单位的所有可用的（未花费的）UTXO。当一个用户接收比特币时，金额被当作UTXO记录到区块链里。这样，一个用户的比特币会被当作UTXO分散到数百个交易和数百个区块中。
      6. 交易的单个输出是UTXO的最小单元
   4. 交易语法
      1. 一个交易分为三部分：元数据/交易输入/交易输出
   5. 元数据
      1. 交易规模
      2. 输入数量
      3. 输出数量
      4. 此交易哈希值
      5. 锁定时间
   6. 交易输入
      1. 引用UTXO的交易ID
      2. UTXO   交易的索引（具体位置）
      3. 解锁脚本（签名/公钥）
   7. 交易输出
      1. 接收金额
      2. 锁定脚本（对方公钥hash,其实是通过地址值获取的一个片段）
   8. 比特币脚本
      1. 输出脚本指定了一个公钥，输入脚本指定了一个对应公钥的签名
      2. 可以理解为类HTML语言，所有节点都能理解，并且按照步骤进行了编译
      3. 比特币语言是一种堆栈式编程语言，意味着每个指令只能被执行一次，是线性的（只产生两个结果，要么成功，要么失败），无法循环执行（图灵不完备，设计者有意为之，防止被恶意提交）
      4. 设计原则就是简明扼要，并内生的支持加密操作
      5. 比特币签名功能有一个缺陷（未修复），CHECKMULTISIG执行时会返回一个没用的值，系统需要接收后再忽略掉。
      6. 在堆栈语言里执行一个脚本，我们只需要一个堆栈来垒积数据，不需要分配任何内存与变量。因此，堆栈语言中计算相当容易。总共有两类指令：数据指令和工作码指令。数据指令的作用是把数据推到堆栈的最上面；工作码指令则通常是用堆栈顶部的数据作为输入值，用来计算一个函数。
      7. 实际除了标准脚本，很少使用，每个节点都有一份标准脚本的白名单，只是使用起来比较麻烦

2. 广播交易（验证交易）

   > 广播交易信息和接收交易信息对节点来说是同步进行的，每收到一条广播信息，就会进行校验，如果有效，则继续向外扩散

   1. 校验过程
      1. 使用解锁脚本对交易的输出进行校验
         1. 使用公钥校验输入的交易是否属于自己
         2. 使用签名，验证其身份
      2. 区块链会为每一次交易盖上时间戳，如果这笔交易中使用的utxo在之后再次花费则会被拒绝
      3. 校验交易输入的过程由两部分组成
         1. 一部分校验发起方拥有这些货币的使用权
         2. 另一部分校验确实是发起人授权使用这部分货币

3. 挖矿竞争

4. 胜出，广播结果

5. 记账，获取奖励，广播账本

6. 同步账本，新一轮竞争

7. 交易标准

   1. P2PKH

      1. P2PKH（Pay-to-Public-Key-Hash）
      2. 比特币网络中的主流方式
      3. 

   2. P2PK

      1. Pay-to-Publick-Key
      2. 比P2PKH少了地址验证（使用公钥生成地址）
      3. P2PKH的核心就是P2PK

   3. MS(Multiple Signatures)多重签名

      1. 通用的M-N多重签名，N表示存档公钥总数，M是要求激活交易的最小公钥数
      2. 锁定脚本含有N个公钥
      3. 签名脚本中含有签名和公钥脚本

   4. PUSH（Pay-to-Script-Hash）

      1. MS多重签名的简化版本

      2. 锁定脚本只需要提供一个计算后的HASH

      3. 就是说付款方不需要了解收款方怎样解锁，只需要知道一个hash值就好

      4. 不是比特币的原始设计，实现有点复杂

      5. 优势：

         1. 付款方工作简单，收款方只需要告诉付款方一个哈希值就好
         2. 锁定脚本体量变小，区块容纳的交易数量提升
         3. P2SH将构建脚本的重担转移至接收方，而不是发送方。

8. 币基交易

   1. 每个区块中向矿工转账的交易
   2. 交易的价值是挖矿奖励加上交易费
   3. 永远只有一个单一的输入和单一的输出
   4. 不会消费UTXO，所以没有上一个交易的指针
   5. 币基交易的参数，矿工可以自定义



#### 1.6 比特币地址

> 比特币中每次交易都会生成一个新的地址（因为比特币的整个交易流程都可追溯，可上溯至打包奖励的区块）
>
> 比特币地址生成过程
>
> 私钥 —> 公钥 --> 地址值

1. 对公钥进行SHA256计算（取20位）
2. version + 第一步的20位  （21位）
3. 对这21位 进行SHA256计算（取4位）
4. 第二步/第三步  拼接25位数据，这就是地址值（25位）

5. 使用base58 进行编码
   1. base58 在base64基础上删掉六个字符（0(零), O(大写o), +, /, l(小写L), I(大写i)）

#### 1.7 找零机制

> 比特币中没有账户，余额之类的概念
>
> 所有的信息都保存在帐本中，每次交易都会遍历相关的交易（遍历到币值够交易使用为止，额度大于等于交易所需，有找零机制）
>
> 每一个交易的输入都是上一个交易的输出
>
> 输入/输出都可以是多个
>
> 每个交易的币值都是原子性的，所以每次转账时，都会将输出交易中的币全部使用，所以有了特殊的找零机制，这是因为每次转入交易获得的币都有一个（以使用/未使用）的属性。

1. 比特币区块可以进行修改
2. 比特币的找零机制是，创建一个支付交易的同时，将剩余币值转给自己

### 1.8 主链选取原则

> 那么，要保证区块链的MainChain唯一性，当出现多处分叉的时候，该用什么准则去选择最佳链（select the bestChain as mainChain）呢？
>
> 1）如果不同分支的区块高度不同，那么选择最长区块高度的分支为MainChain（在POW共识机制下，最长工作量代表着最权威的说服力）；
>
> 2）如果高度一致，则选择难度系数最大的分支为MainChain（在POW共识机制下，difficulty越大，则说明该区块被创造所需要的工作量越大，则权威说服力越大）；
>
> 3）区块高度如果相同，并且难度系数也一样，那么选择接受时间最早的那个分支为MainChain；
>
> 4）若所有的评判系数均相同，则等待各自某分支的区块高度+1之后，重新重复上述1~3步骤选择出一个BestChain。

### 1.9 第三方支付

> 通过使用MS（多重签名模式）实现第三方担保，要求有两方同意，该笔资金才能使用。
>
> 当交易双方都满意是，可以直接交易，交易双方有分歧时，第三方介入，决定资金流向
>
> 以太坊智能合约实现起来很简单，创建一个独立智能合约用于做简单投票机制，买方/卖方谁获得两票，资金转给谁。

### 1.10 绿色账户

> 比特币体系中出现的一种提高交易效率的应用
>
> ps: 现有体系中，普遍认为一笔交易六次确认后才认为已经转账成功，对部分应用场景，时间过长
>
> 绿色账户是第三方权威机构（银行），当转账行为发生时，A转向银行，银行转向B（银行保证其账户不发生双花现象）

### 1.11 高效小额支付

> 例如按量付费模式，随着使用量增多，需要不停创建小额的交易，支付费用，这样一是比特币的效率难以支撑，二是手续费高昂
>
> 解决方案：发起方发起一个MULTISIG交易，先预付资金到MULTISIG地址，该交易需要交易双方同时签名才能生效。在消费得过程中每隔一段时间，买家进行一次签名，直到最后一次消费结束，通知卖家停止服务并进行签名
>
> 整个过程中买方单独签名的交易，不会进入区块链中（交易校验时会舍弃）

### 1.12 锁定时间

#### 1.12.1 交易级别

> 1. 交易锁定时间（nlocktime）
>    1. 这是交易数据结构中的一个字段，标识交易生效并且在网络中中继或添加到区块链中的最早时间（不到时间，不转发，不添加入区块）
>       1. 如果在nlocktime之前被发送到网络，第一个接收到的节点会拒绝该交易，认为其无效，且拒绝转发
>    2. 可以是一个绝对时间点或者区块高度
>       1. 如果nlocktime不为0且小于5亿，则nlocktime表示区块高度
>       2. 高于5亿，则解释为Unix时间戳
>    3. nlocktime只是一种未来交易的约定，不能避免双花问题

#### 1.12.2 utxo级别

> 1. 检查锁定时间验证 Check Lock Time Verify（CLTV）
>
>    ulocktime是交易级别的时间锁定，CLOV是utxo级别的时间锁定，所以CLOV只能比nlocktime更大
>
>    CLTV采用与ulocktime相同的时间格式，
>
>    包含CLTV的交易可以加入到区块中，只是该utxo暂时不能被使用
>
>    通过ulocktime 与CLTV相结合，可以实现较严谨的未来交易
>
>    失败判定：
>
>    ​	堆栈是空的；或者
>    ​	堆栈中的顶部项小于0；或者
>    ​	堆栈中的顶部项的锁定时间类型（区块高度或者时间戳）和nLocktime字	段的锁定时间类型不相同；或者
>    ​	堆栈中的顶部项大于交易的nLocktime字段；或者
>    ​	输入的nSequence字段值为0xffffffff。
>
> 2. 相对时间锁（nSequence)
>    1. 在输入中设置nSequence相对时间锁
>    2. 本意是用来标识交易状态，nSequence小于2 ^32（0xFFFFFFFF），则表示处于未完成状态，不入链，这种初衷并未得到实现
>    3. 现在nSequence小于2^32标识设定了一个相对时间锁， 这种输入到了相对锁定的时间后才能生效，所以不使用该功能的交易，将该值设定为2^32，使用nlocktime和CLTV的交易，则需要设定小于2^32，以使时间锁定器有效，通常设置为2^32 -1 (0xFFFFFFFE)
>    4. 时间格式不同于nlocktime，一个类型标志被用来区分 nSequence 值是计算区块数还是计算时间（以秒为单位）
>    5. 操作脚本（CSV，checkSequenceVerify）
> 3. 中位过去时间
>    1. Median-Time-Past，主要是为了缓解网络延迟造成的影响
>    2. 区块头中设置的时间戳是由矿工设定的。共识规则允许分散节点之间的时钟精度存在一定范围的差别。然而这导致了一个不幸的诱因，它诱使矿工对于区块的时间进行说谎
>    3. 获取最后十一个区块的时间戳并找到中位数作为（MTP），这个值被用于所有时间锁定，用以减少某个区块矿工利用网络延迟动手脚（挖掘未到解锁时间的交易牟利）。
>    4. MTP有一个小时左右的延迟，所以利用ulocktime/CLTV/CSV 需要考虑加上这一个小时的延迟
> 4. 针对费用狙击（Fee Sniping）的时间锁定
>     	1. 费用狙击就是重新挖掘当前最高区块，选择内存池中收益较高的交易进行重新打包
>     	2. 用于解决分叉攻击
>     	3. Bitcoin Core在创建交易时，将ulocktime设定为 现在区块高度+1  ，正常情况下该设定没有影响，当遇到分叉攻击（恶意矿工尝试重新挖掘现在最高区块）时，也只能使用之前的的交易

### 1.13 智能合约

> 比特币脚本语言功能性较差，实现起来复杂。。。

### 1.14 比特币网络

#### 1.14.1 点对点网络

> 特点：
>
> 1. 所有节点都平等（没有特殊节点）
> 2. 运行在TCP网络中，8333 端口
> 3. 有一个随意的拓扑结构，每个节点和其他随机节点相连
> 4. 节点的加入和离开不受限制
> 5. 一个节点三个小时没有音讯，会慢慢被网络舍弃
>
> 加入过程（每次启动都会有这个动作）：
>
> 1. 连接一个已知的节点（种子节点，一般软件会维护一个较稳定的种子节点列表）
> 2. 将本身信息（包含IP地址）发送给相邻节点，相邻节点会依次进行转发，保证网络稳定性
> 3. 向相邻节点发送getaddr信息（要求返回其已知对等节点的IP地址列表）
> 4. 这个过程重复几次，就称为一个合格的节点了（并不需要保存网络中所有的节点，也是出于泛洪操作时的效率方面考虑）
>
> 分类：
>
> 1. 全节点：四个完整功能：钱包，矿工，完整区块链，网络路由节点
> 2. 轻节点：用作SPV（简易支付验证，Simple Payment Verification），两个功能：钱包，网络路由节点，大部分的钱包软件都属于此类节点
>    1. 轻节点可以校验区块---因为其加载了区块头部数据
>    2. 不能校验区块中的交易记录有效性----因为没有加载全部信息（交易记录，utxo列表）
>    3. 依赖于全节点去校验交易
> 3. 功能节点：例如挖矿节点，三个功能节点：矿工，完整区块链，网络路由节点
>
> 交易转发：
>
> 1. 使用泛洪（flooding）算法进行组播（已知节点列表）
> 2. 节点对接收到的信息进行校验，对有效交易加入交易池并再次泛洪中继
> 3. 接收到交易池中已存在的交易，不对其进行转发，保证了泛洪协议终结
>
> 校验过程（交易过程并不是强制执行的，但一般都会进行）：
>
> 1. 交易校验：使用签名脚本校验输入的锁定脚本
> 2. 检查是否双重支付
> 3. 检查交易信息是否已接受过
> 4. 节点只接收和传递在白名单上的标准脚本
>
> 竟态条件：
>
> 1. 由于网络延迟，如果有节点发出双重支付，位于网络不同位置的节点，首先收到的交易可能不同，网络中就哪一个交易将被加入区块链会产生分歧
> 2. 交易的竟态条件由下一个区块的矿工决定，将哪一个交易打包，哪一个交易被认为胜出，其他节点会将相关交易移除内存池
> 3. 区块的分发也同样会有静态条件发生（不同矿工近乎同时挖矿成功），节点先接受到哪个，取决于在网络中的位置
> 4. 具体节点选择哪个交易或区块，完全可以由节点自己决定，所以恶意节点是可能存在的

### 1.15 零验证交易

> 交易一旦发起，且发送至网络中，接收方就接受该交易
>
> 可能会被双花攻击，

### 1.16 费用替代策略

> 起初矿工对待双重支付的态度是，接受先接收到的交易
>
> 2013年后，变成了“费用替代策略",即节点在遇到交易竟态条件时，会保留交易手续费更高的交易，舍弃手续费较低的交易

### 1.17 地址

> 比特币中地址主要有两种存在方式：
>
> 1. 字符串形式，使用bash58进行编码
> 2. 使用二维码模式
>
> 虚荣地址：
>
> 1. 生成一个，拥有特殊字段的地址对应的密钥对

### 1.18 比特币存储

> 热存储：将比特币保存在钱包软件中（安全性不太高）
>
> 冷存储：离线存储
>
> 分层确定性钱包：
>
> 大脑钱包：利用特定语句生成密钥
>
> 防损硬件：
>
> 密钥分存和密钥共享
>
> 门限签名：将密钥切分不同片段，分比储存
>
> 多重签名（multisignatures）
>
> 在线钱包：云端存放密钥，通过密码访问

### 1.19 交易所

> 类似于传统银行，进行比特币的存储，交易，法币兑换
>
> 三类风险：
>
>  	1. 挤兑
>  	2. 庞氏骗局（监守自盗）
>  	3. 黑客入侵
>
> 监管：
>
> 1. 准备金制度（通过发起一笔目标交易，并用私钥签名一条查询交易，证明该笔资金是自己可控的）
> 2. 负债证明（proof of liabilities）（交易所将所有人的存款信息加入到一个merkel-root中，提供用户所对应节点的子树）
>
>

### 1.20 匿名性

> 比特币的地址是公钥哈希值
>
> 在与比特币系统交互的过程中，使用者不需要使用真实的姓名，使用公钥哈希值作为交易标识
>
> 比特币本身只是一个化名系统（防君子不防小人）
>
> 保护用户的匿名性，在钱包开发中，保证零钱地址的位置永远是随机的

#### 1.20.1 旁路攻击（side channels)

> 即使没有发生直接的关联，因为侧面渠道或者一些间接的信息泄露，用户的匿名身份也可能会暴露
>
> 防范：
>
> 1. 同一个用户的不同地址应该不易关联
> 2. 同一用户的不同交易应该不易关联
> 3. 一个交易的交易双方应该不易关联

#### 1.20.2 污点分析（taint  analysis)

> 寻找不同地址之间的关联性（不管直接还是间接，两者之间经常发生交易）

#### 1.20.3 关联性分析

> 分析交易中的地址，将识别输出中的找零地址，与输入地址进行归集，形成一个可能是同一个身份的地址
>
> 通常钱包生成的找零地址是一个新地址，这可以作为一个分析点

#### 1.20.4 利用交易进行标记

> 通过对同一商家发出交易，掌握一个地址的身份属性，然后对其归属的地址簇进行标记

#### 1.20.5 分析个人身份

#### 1.20.6 网络层的匿名处理

> 在分层中，区块链归于应用层，点对点网络则属于网络层
>
> 网络上足够多的节点串联起来，可以监听第一个广播交易的节点，通过IP找到对应的用户

#### 1.20.7 混币（Mixing）

> 通过一个中介媒体，会产生混币服务费，而且依赖中介机构的道德水平
>
> 钱包混币：会在服务商留下记录
>
> 专业混币：基本上是无痕迹的（tor网络）
>
> 多重混币：已经被广泛使用

#### 1.20.8 分布式混币

> 用户间自行组建一个用于混币的匿名网络，通过匿名网络协议通信

#### 1.20.9 高风险交易流

> 容易被旁路攻击的一些规律性的交易（如发薪酬/交社保等）
>
> 合并规避（merge avoidance）: 接收方提供不止一个接收地址，发送方每次给不特定地址发送比特币

#### 1.20.10 零币/零钞

> 零币相当于生成一个拥有证明，零币与基础币之间没有联系。个人理解：往一个集合中存入基础币，获得相应的零币，实际使用时，用零币获取的基础币与原有基础币之间没啥关系
>
> 零钞：建立在零币基础上