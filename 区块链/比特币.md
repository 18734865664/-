## 比特币

### 1. 手记

1. 比特币是种数据结构，容量有限（目前每个区块1m，大约存储4200条交易，每秒约处理7比左右）
2. 基于hash的向左的单向链表结构
3. 记账权基于hash碰撞（通过调整匹配位数，调整难度），通过计算寻找满足特定SHA-256哈希值对应的数值解
4. 使用levelDB作为底层数据存储
5. 因为每笔交易都在公众面前，所以追踪一笔比特币交易比追踪人名币方便的多
6. 每21w个区块，奖励减少一半
7. 从中本村的初衷看，将比特币类比做贵金属，是希望像贵金属一样，随着用户的热动变化，其本身价值变动，比特币本身数量不变（以期达到抗通胀的作用），这其实就是把比特币定位到了收藏品的位置，而不是一种交易流通介质。所以，现在比特币的流通性并不强
8. 对中本村来说，比特币系统更像一个社会实验，走到今天完全是意外

#### 1.1 区块（block)

> 区块链的基本结构单元
>
> 两部分组成：
>
> 1. 包含元数据的区块头
>
>    			2. 包含交易数据的区块主体构成
>
> 区块中不保存本区块的hash值，比特币中维护两个数据库：
>
> 1. 区块数据
> 2. 区块数据同hash之间的映射关系（本区块的hash在节点接收到区块时，计算得到，然后保存到对应关系库中）
>
> 区块的hash指的是对区块头进行hash运算，不是整个区块体。

##### 1.1 1 区块头（分为三部分）

 1. 用于连接父级区块的hash值

 2. 挖矿难度、Nonce(随机数，用于POW算法的计数器），时间戳

 3. 能够总结并快速归纳校验区块中所有交易数据的merkle（默克尔）树根数据

    [默克尔树参考![merkle树结构](H:\go\markdown\区块链\img\merkle树结构.png)](https://blog.csdn.net/weixin_37504041/article/details/80474636)

##### 1.1.2 区块体

1. 区块体中是二叉树结构的默克尔树
2. 所以交易数必须为偶数，如果不是，则会将最后一个交易复制一份，然后生成
3. Merkle树的叶子节点存储的是数据信息的哈希值，非叶子的节点存储的是对其下面所有叶子节点的组合进行哈希计算后的出的哈希值
4. 区块两种有两种交易：
   1. 挖矿交易（永远在区块体中的第一条记录）
   2. 其他交易

##### 1.1.3 加密算法

​	区块链中，通常使用SHA-256(安全散列算法)进行区块加密

##### 1.1.4 公钥和私钥

 	1. 比特币系统中，私钥本质上是32个字节组成的数组，公钥和地址的生成都依赖私钥。
 	2. 私钥花费比特币的方式：使用私钥对未花费的交易进行签名
 	3. 比特币中使用椭圆曲线算法（ECC）

##### 1.1.5 时间戳

> 区块链中的时间错从区块生成的一刻起就存在于区块中了

#### 1.2 节点（node）

> 每个运行软件的实体成为一个节点
>
> 比特币中没有私钥--余额表单，发起的交易检验时，需要遍历整个账本（这效率。。。）

* 轻节点（只下载block头部和与自己相关的交易记录）
* 全节点（下载全部block）

#### 1.3 POW(工作量证明) -- 别名：挖矿

* POW：Proof of Work

* 每个block的数据都不完全一样

* 大概十分钟新生成一个block

* 有人挖矿成功，则同步新的账本，将其中已处理的交易剔除后生成新的block，参与下一次竞争。

* 对当前打包好的交易进行哈希SHA256运算，然后进行碰撞

  > SHA256(区块数据 + 随即数据) < 目标的哈希值
  >
  > 目标哈希值 由n个前导零和一串十六进制数组成（整体由难度系数）
  >
  > 目前pow的难度系数，每2016个区块调整一次

* POW意味着持续的能源消耗，现在社区对是否将比特区技术的共识机制进行调整，有分歧


#### 1.4 分叉

##### 1.4.1 软分叉

 	1. 软分叉是暂时的
 	2. 当新的共识规则发布后，没有升级的节点由于不了解新的机制，生成一些“不合格”的区块
 	3. 宏观上，并没有分叉，新旧版本的区块存在于一个链条之上，互相之间可确认。
 	4. 相当长的时间内，允许旧版本不升级，新旧版区块共存。

##### 1.4.2 硬分叉

 	1. 硬分叉是永久性分歧
 	2. 分为了新链和旧链
 	3. 硬分叉是指比特币的区块格式或交易格式（共识）发生改变时，未升级的节点拒绝验证已经升级的节点生产出的区块，已升级的节点则可以验证未升级节点生产出的区块
 	4. 以太坊2016.7 执行了硬分叉，一条ETC(原链)，另一条ETH(分叉链)



#### 1.5 交易流程

1. 创建交易

   1. 创建交易时遍历账本
   2. 提供一个解锁（输入）脚本/锁定（输出）脚本，矿工使用这两个脚本校验交易
      1. 解锁脚本中包含签名/公钥，对输入中的交易进行解锁才能使用其中的币
         1. 签名：对引用的交易ID进行了签名
         2. 交易时交易内容的hash
         3. 每个引用都有一个解锁脚本
      2. 锁定脚本中使用
   3. UTXO(unspent transaction output, 未花费的余额)
      1. UTXO没有一个专门字段存储，是遍历帐本后的一个展示
      2. UTXO只能一次花完，找零就是生成一个更小的UTXO
      3. 比特币余额：就是扫描整个链，聚合所有属于用户的UTXO
      4. 比特币为了优化交易，会将所有的UTXO（chainstate目录中内容）存储到全节点的内存中，称为utxo账本/UTXO池
      5. 比特币网络监测着以百万为单位的所有可用的（未花费的）UTXO。当一个用户接收比特币时，金额被当作UTXO记录到区块链里。这样，一个用户的比特币会被当作UTXO分散到数百个交易和数百个区块中。
      6. 交易的单个输出是UTXO的最小单元
   4. 交易输入
      1. 引用UTXO的交易ID
      2. UTXO   交易的索引（具体位置）
      3. 解锁脚本（签名/公钥）
   5. 交易输出
      1. 接收金额
      2. 锁定脚本（对方公钥hash,其实是通过地址值获取的一个片段）

2. 广播交易（验证交易）

   > 广播交易信息和接收交易信息对节点来说是同步进行的，每收到一条广播信息，就会进行校验，如果有效，则继续向外扩散

   1. 校验过程
      1. 使用解锁脚本对交易的输出进行校验
         1. 使用公钥校验输入的交易是否属于自己
         2. 使用签名，验证其身份
      2. 区块链会为每一次交易盖上时间戳，如果这笔交易中使用的utxo在之后再次花费则会被拒绝
      3. 校验交易输入的过程由两部分组成
         1. 一部分校验发起方拥有这些货币的使用权
         2. 另一部分校验确实是发起人授权使用这部分货币

3. 挖矿竞争

4. 胜出，广播结果

5. 记账，获取奖励，广播账本

6. 同步账本，新一轮竞争

#### 1.6 比特币地址

> 比特币中每次交易都会生成一个新的地址（因为比特币的整个交易流程都可追溯，可上溯至打包奖励的区块）
>
> 比特币地址生成过程
>
> 私钥 —> 公钥 --> 地址值

1. 对公钥进行SHA256计算（取20位）
2. version + 第一步的20位  （21位）
3. 对这21位 进行SHA256计算（取4位）
4. 第二步/第三步  拼接25位数据，这就是地址值（25位）

5. 使用base58 进行编码
   1. base58 在base64基础上删掉六个字符（0(零), O(大写o), +, /, l(小写L), I(大写i)）

#### 1.7 找零机制

> 比特币中没有账户，余额之类的概念
>
> 所有的信息都保存在帐本中，每次交易都会遍历相关的交易（遍历到币值够交易使用为止，额度大于等于交易所需，有找零机制）
>
> 每一个交易的输入都是上一个交易的输出
>
> 输入/输出都可以是多个
>
> 每个交易的币值都是原子性的，所以每次转账时，都会将输出交易中的币全部使用，所以有了特殊的找零机制，这是因为每次转入交易获得的币都有一个（以使用/未使用）的属性。

1. 比特币区块可以进行修改
2. 比特币的找零机制是，创建一个支付交易的同时，将剩余币值转给自己







 	1. 