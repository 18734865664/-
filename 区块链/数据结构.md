# 数据结构

> 数据结构
>
> 1. 这是计算机存储器的一个逻辑组织
> 2. 通常指存储单元地址的使用模式
>
> 数据类型：
>
> 1. 这是程序语言中的概念

## 1 线性表

> 存储单元 -->   数据项（字段field）  -->  记录(record)
>
> 一系列存储单元类型相同，有固定间隔且在内存中连续，这些存储单元组合在一起的存储单元称为表

### 1.1 单链表

> 每个数据块，记录一个字段（NEXT字段）指向下一个区块（Node）的指针变量
>
> 与表相比：
>
> 1. 插入/删除记录速度更快（只需要重拍少量node即可），所以对动态结构更友好
> 2. 读取固定单元耗时更长（只能通过从头遍历链表获取）
> 3. 可以不需要提前知道存储量（在内存中不连续存储）
> 4. 内存开销更大（有一个Next字段）
>
> 遍历链表：
>
> 1. 顺序遍历
> 2. 逆序遍历：
>    1. 使用递归方式，一探到底
>
> 其他链表：
>
> 1. 循环单链表
>    1. 最后一个区块的Next指向head
> 2. 双向链表
>    1. 每个区块除了Next指针，还有一个Pre指针指向上一个
> 3. 循环双向链表
>    1. 最后一个区块的next指向Head

## 2 栈与队列

> 栈是限制插入和删除只能在同一个位置进行的表，该位置是表的末端，叫做栈顶，
>
> 入栈/出栈操作，LIFO(last   in   first out)，后进先出

> 队列：特殊的线性表，只允许在表前端进行删除，在表末端进行插入操作
>
> ​	FIFO(first  in  first out)，先进先出
>
> 队列可以使用链表/数组实现，单向队列和循环队列两种，可以结合map实现无重复内容的队列

## 3. 树与二叉树

### 3.1 树

> 普通树结构：
>
> 1.  n个有限节点组成的一个具有层次关系的集合
> 2. 每个节点，有零个或多个子节点
> 3. 只有根节点没有父节点
> 4. 每个非根节点有且只有一个父节点

### 3.2 二叉树

> 二叉树的每个节点至多只有两个子节点，子节点有左右之分，次序不能颠倒
>
> 二叉树的操作大量使用递归
>
> 叶子节点：没有子节点的节点
>
> 每层节点上限为2  *  (n-1)，总结点数为  2 ^ n- 1
>
> 满二叉树：所有子节点位置都有元素的二叉树
>
> 完全二叉树：从倒数第二层起，符合满二叉树，最后一层允许空缺，但叶子节点靠左对齐。
>
> 完美二叉树：只要节点有子节点，就一定是有两个子节点（填充满），不存在“独生子”
>
> 二叉树三元素
>
> 1. 根节点
> 2. 左子树
> 3. 右子树
>
> 三种遍历顺序：
>
> 1. 先序遍历：若二叉树为空，则空操作，否则先访问根节点，再先序遍历左子树，最后先序遍历右子树。
> 2. 中序遍历：若二叉树为空，则空操作，否则先中序遍历左子树，再访问根节点，最后中序遍历右子树
> 3. 后序遍历：若二叉树为空，则空操作，否则先后序遍历左子树，再后序遍历右子树，最后访问根节点
>
> 删除操作：
>
> 1. 如果要删除的节点只有一个子节点，直接使用子节点替换即可
> 2. 如果要删除节点有两个子节点，使用右子节点中最小的节点替换
>
> 平衡二叉树：
>
> 1. 平衡二叉树又称AVL树，它或者是一棵空树，或者是具有下列性质的二叉树：它的左子树和右子树都是平衡二叉树，**且左子树和右子树的深度之差的绝对值不超过1**
> 2. 增加和删除可能需要通过一次或多次旋转来重新平衡这个树。
>
> 红黑树：
>
>  	1. 平衡二叉树的一种
>  	2. 红黑树放弃了追求完全平衡，追求大致平衡，在与平衡二叉树的时间复杂度相差不大的情况下，保证每次插入最多只需要三次旋转就能达到平衡，实现起来也更为简单。
>  	3. 平衡二叉树追求绝对平衡，条件比较苛刻，实现起来比较麻烦，每次插入新节点之后需要旋转的次数不能预知

### 大小端问题

> 低地址位保存高位数 ---- 大端，就是从左往右读
>
> 地位地址保存地位数  ---- 小端  
>
> socket网络通信不需要考虑这个问题，传送的是字节序，每个字节只占用一位，不存在大小端的问题
>
>