## 密码学

### 简介

​		密码学 ≠ 研究加密算法

​		密码学 = 加密学 + 解密学

​		密码学：研究编制密码和破译密码的技术科学



### 三要素

1. 明文/密文：

2. 密钥：
   1. 一个定长的字符串，由使用的加密算法决定
   2. 对称加密
      1. 加/解密使用的密钥相同，或者加/解密密钥可以很容易推导出对方
      2. 特点
         1. 双向保证机密性
         2. 加密效率较高
         3. 相对于非对称加密，加密强度不高
   3. 非对称加密
      1. 加/解密使用完全不同密钥，两者之间完全不可推导，由加密算法生成，加/解密双方分别使用公/私钥
      2. 公钥
      3. 私钥
      4. 特点
         1. 单向保证机密性
         2. 加密效率低
            1. 实际使用中通常对文本的hash摘要签名而不是文本本身
            2. 或者进行多次对称加密后，将密钥使用非对称加密，传给对方，兼顾了安全性和效率
         3. 加密强度高
         4. 减少了网络用户保管的密钥数
      5. 总体思路是：单向计算很容易，逆向计算很困难，或几乎不可行
      6. 数字签名：
         1. 使用私钥加密，公钥进行解密
3. 算法：
   1. 加密算法
   2. 解密算法

### 密码体制

1. 错乱
   1. 按规定的图形或线路，改变明文的位置
2. 代替
   1. 使用约定的明文字母/内容替换部分内容形成密文
3. 密本
   1. 使用预编制的密码本
4. 加乱
   1. 使用一个预设序列作为乱数，按照规定算法，同明文序列结合变成密文
5. 上面四种基础密码体制可以单独使用，也可以混合使用



### 密码学目标

1. 保密性

   1. 通过加密实现
   2. 一个密码系统的安全性在于密钥的保密性，不在于算法的保密性

2. 完整性

   1. 一般通过单向hash实现，即将输入加工生成一个定长的文本摘要

3. 认证

   1. 身份特征或消息实体的代表属性

   2. 用于实现某种行为的认证

4. 不可否认性

   1. 与认证很类似，主要用于表征某些不可否认的行为
   2. 如数字签名



### 对称加密

```
以分组为单位进行处理的密码算法称为分组密码（blockcipher）
分组后内容通过异或等手段进行加/解密
```



#### DES(Data Encription Standard)

1. 密钥长度64bit，每个7bit有一位用于错误检查（奇偶校验和，即使1的个数为奇数），所以实际长度位56bit

2. 属于分组加密算法，分组长度

3. 现在已经不安全

4. 加密得到的密文长度与明文长度相等

5. DES包含16个阶段的替换-置换加密法

   1. 每个阶段使用不同的子密钥和上一阶段的输出


#### 3DES

1. 相当于进行三次DES加密，传入的密钥在算法中被拆分为三个密钥，分别进行三次DES过程
2. 有两种版本：
   1. 三密钥版本
   2. 两密钥版本
      1. key1 ==  key3
3. 3DES的加密过程：明文 --> DES加密（密钥1）-->DES解密（密钥2）-->DES加密（密钥3）-->密文   
   1. 使用这种模式，是为了兼容DES算法
4. 密钥长度位256bit（24Byte），分组长度64bit
5. 目前还未被破解

#### AES(Advanced Encryption Standard)

1. 分组长度为128bit
2. 密钥长度 32bit为单位，128/192/256之间选择一种
3. go语言中提供的接口只能是128bit
4. 效率很高

### 分组密码模式

1. ECB模式
   1. 电子密码本模式
   2. 已经不再安全
   3. 需要填充内容
2. CBC模式
   1. 加密链模式
   2. 安全/推荐使用
   3. 需要填充内容
3. CFB模式
   1. 密文反馈模式
   2. 
4. OFB模式
   1. 输出反馈模式
5. CTR模式
   1. 计数器模式
   2. 不需要填充内容
   3. 效率很高，支持并行加密，所以效率很高

### 编码概念

1. 比特序列
   1. 计算机体系中使用0，1字符流
2. 编码
   1. 将实际物体映射为比特序列的操作（encoding）
3. 

### 加密技术分类

1. 公钥/私钥(public key and private key)
   1. 也称为RSA编码法，利用两个很大的质数的乘积进行加密，这两个质数无论使用哪一个与源文件编码相乘加密，都可以使用另一个质数相乘来解密。
   2. 使用一个质数来求出另一个质数十分困难
2. 数字摘要（digital digest）
   1. 称为SHA（Secure Hash Algorithm）或MD5（MD Standards for Message Diatest）
   2. 采用单向Hash函数将需要加密的明文摘要成固定位数密文，摘要密文称为（Finger Print）数字指纹
   3. 数字指纹有固定的长度，相同明文总是生成相同的摘要，不同明文总是生成不同的摘要。
3. 数字签名（digital signature）
   1. 上面两种方式结合起来，可以实现数字签名技术
   2. 将文本使用SHA获取摘要，使用密钥对加密后发给对方，
   3. 接收方使用密钥对对摘要解密，同时对文本使用SHA获取摘要，如果摘要相同，则表示未被篡改
4. 数字时间戳（digital Time -stamp）
5. 数字凭证（digital certification，digital ID）

### 经典密码学

#### 关键字加密法

1. 使用某个单词，去重后，置于字母表中任意位置，其他位置元素顺序位置不变
2. 

![关键字加密法](H:\go\markdown\密码学\img\关键字加密法.png)

#### 仿射加密法

1. 使用工具破解，比关键字加密法更容易破解

#### 多文字加密法

1. 使用一对字母替代每个明文字母
2. 脆弱

#### 经典多码加密法

1. 每个明文字母可以用密文中多个字母替代，每个秘文字母可以表示多个明文字母
2. 

### 现代加密法

```
XOR：异或运算，特质时连续对同一字符串进行异或操作，会得到本身
```



#### 流加密法

1. 生成一个同明文等长的密钥，同步加密
2. 有点是几乎不能破解

#### 块加密法

1. 填充问题
   1. 块加密法作用于固定大小的块，所以加密算法如果作用于明文，明文需要补位值能够被block长度整除

### 非对称加密





### 3. 消息认证码

> 消息认证码（message authentication code）确认完整性并进行认证的技术（保证数据未被篡改过）

#### 3.1 手段

> 对信息进行散列值计算/校验，散列值通过共享密钥进行加密	

#### 3.2 go中封装

> hmac 包中封装
>
> 其中原理，使用对称加密，且将内容和密钥同时计算得到散列，并返回

#### 3.3 实现过程

* hm :=hma

### 4. 数字签名

> 第三方认证
>
> 三方机构对传输数据的hash散列进行私钥加密
>
> 其他机构进行公钥解密，验证其权威性
>
> 两个特性需求：
>
> 1. 只有自己能制作自己的签名，且任何人都可以验证有效性
> 2. 一个签名只与一份特定文件对应，不能与另一份文件对应
>
> 三个步骤：
>
> 1. 生成密钥对（generateKeys)
> 2. 签名（sign)
> 3. 校验（verify）
>
> 签名算法技巧：
>
>  	1. 要注意签名算法中随机数的良好来源（如果使用同样的随机来源或者可预测的随机，会加快破解速度），保证安全性
>  	2. 对哈希摘要进行签名而不对文本本身签名，保证了安全性和效率
>  	3. 对哈希指针签名，相当于签名了整个数据结构（如整条区块链）
>
> 比特币签名算法：
>
> 1. 椭圆曲线数字签名算法（ECDSA）
>
> 公钥即身份（公钥校验信息，验证确实是其发出的消息）
>
>



## 5. 哈希函数

> 不定长输入，定长输出

### 5.1 碰撞阻力

> 碰撞指不同输入产生相同输出
>
> 碰撞阻力：对于哈希函数H(.)，没有人能够找到碰撞
>
> 这里的没有人能够找到，不是说不存在碰撞（定长就说明，有一个寻找相同hash的最少次数）
>
> MD5已经被人找到了碰撞，逐渐被淘汰
>
> 应用场景：文件摘要

### 5.2 隐秘性

> 简单说，无法反推
>
> 签名过程：com := commit(msg, nonce)
>
> 校验过程：verify(com, msg, nonce)          // 对外公布摘要com和随机数nonce，供人校验msg
>
> 应用场景：承诺，数字签名

### 5.3 谜题友好

> 解释：如果想找到y值所对应的输入，假定在输入集合中，有一部分是非常随机的，那么将非常难以求得y值对应的输入
>
> 这部分随机范围要足够大，这样可以避免作弊
>
> POW共识机制中，nonce充当这个随机值

### 5.4 安全哈希算法（sha256）

> MD变换（Merkle-Damgard）：将接受固定长度的哈希函数转化为可接受任意长度输入的哈希函数，要求按输出长度为n，输入长度m分组，将输入按照m-n长度分组，每次进行hash后，加上前一次输出n +  下一区块m - n ，作为输入进行hash，最后一个区块的输出就是结果
>
> 压缩函数（compression function）：可用于固定长度，具备碰撞阻力的哈希函数，SHA-256就是其中一种

## 6 哈希指针及其应用

> 哈希指针是一种数据结构，是一个指向数据存储位置及其位置数据的哈希值的指针
>
> 与普通指针相比：
>
> ​	普通指针：标识数据存储的位置
>
> ​	哈希指针：标识数据存储的位置、验证数据有没有被篡改

### 6.1 区块链

> ​	在普通链表中有一系列区块，每个a区块既有数据也有一个指向上一个区块的指针。而在**区块链**中，上一个区块指针被置换为哈希指针。因此，每个区块不仅能告诉我们上一个区块的值在哪里，还包含了该值的摘要，使我们能够验证那个值没有改变。我们存储链表头部（the head of list），即一个普通的哈希指针指向最近使用的数据区块。
>
> ​	如果要要篡改某个区块的数据，需要更改该区块一直到创世区块中所有的哈希指针

### 6.2 默克尔根（merkle  trees）

>​	默克尔根：使用了哈希指针的二叉树结构
>
>​	假设我们有很多包含数据的区块，这些区块就构成了树的叶子（节点）。我们将这些数据区块两两分组，然后为每一组建立一个有两个哈希指针的数据结构，每个指针对应一个区块，这些数据结构就构成了树的下一个层次。我们轮流将这些区块组两两分组，为每一组建立一个包含每个区块组哈希指针的新的数据结构。以此类推，直到我们得到一个单一区块，即树根节点。
>
>​	记住最顶端的哈希指针，就可以保证数据篡改会被发现
>
>​	只要提供了顶端指针到数据区的路径，就可以证明该数据区块隶属于该默克尔根
>
>​	将merkle trees 底层数据按照某种排序（字母表排序/数字化排序等），计算后得到的merkle  trees 称为排序默克尔树
>
>​	排序默克尔树可以快速验证数据区块的非隶属性，如果待验证区块前后的两个区块在默克尔树中是连续的，则待验证区块不属于该默克尔树（属于排序默克尔树的数据区块是连续的，待验证区块前后的区块之间要有空间，才能存放该数据）
>
>





