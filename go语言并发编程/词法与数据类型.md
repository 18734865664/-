## 词法与数据类型
### 基本词法
go语言的语言符号（词法元素）
1. 标识符（identifier）
	1. 若干个字母，下划线“_"和数字组成
	2. 第一个字符必须为字母
	3. 字母是指符合Unicode编码的广义字母
	4. go语言使用首字符大写控制访问权限
	5. 预定义标识符：error,true之类
	6. 空标识符：”_“
		1. 特殊用法：只想执行一下某个代码包中的初始化函数，而不需要使用代码包中的任何程序实体的时候
		import _  "runtime/cgo"
2. 关键词（keyword）
	1. 编程语言保留而不让编程人员作为标识符使用
	2. 三类（共25个）：
		1. 程序声明：import， package
		2. 程序实体声明和定义：chan, const, func, interface, map, struct, type, var
		3. 程序流程控制：go, select, break,case，continue，default，defer, else, fallthrough, for, goto, if, range,return, switch
3. 操作符（operater）
	1. 操作符就是用于执行特定算法或逻辑操作的符号
	1. 表达式中有两个部分，
		1. 一个部分是操作符，
		2. 另一个部分是操作数，操作数都是以补码的形式存在
	2. 一元运算符
		1. *，& 单独运算是地址操作符
			1. 对一个复杂类型进行取地址操作，由于符合类型在赋予具体值之前，没有任何指针类型值与之对应，这时，go语言会为这个符合类型字面量所代表的值专门生成一个指针类型，所以可以完成取地址操作
	3. 二元运算符
		1. “/”， “%” 共同实现了舍尾除法
			1. 除法运算实现了向上取整
			2. % 获取余数
		2. “&^” 清零操作，将运算符左边数据相异的位保留，相同位清零
		3. &, * 作为二元运算符是算术运算符
		4. 接收运算符（<-)
			1. 从一个通道类型的空值（nil)接收值的表达式会永远被阻塞
			2. 从一个已被关闭的通道类型值接收值会永远成功并返回一个其元素类型的零值
	4. 注意：go语言中没有三元运算符
	5. 数据对同一个数两次异或，结果与原值相同
	6. 
![运算符优先级.png](.\image\运算符优先级.png)

4. 分隔符（delimiter）
5. 字面量（literal）

		go语言代码由若干个Unicode字符组成，go语言所有源代码都必须由Unicode编码规范的UTF-8编码格式进行编码。

###类型
go语言中的类型可以分为静态类型和动态类型：
1. 静态类型
	1. 一个变量的静态类型是指在变量声明中示出的那个类型
2. 动态类型
	1. 运行时随绑定变量的具体类型关联

	普通变量只拥有静态类型，唯独接口类型的变量除外，它除了拥有静态类型外，还拥有动态类型。
    
潜在类型：
	潜在类型是指各种非基本类型底层实际的预定义类型
    例如：一个数组类型的变量声明中的类型决定了在这个变量中可以存放哪一个类型的元素，换句话说，一个数组类型的潜在类型决定了在该类型的变量中可以存放哪一个类型的元素
    
    
### 表达式

	go语言中，表达式是构成具有词法意义的代码的最基本元素
    
1. 基本表达式
2. 选择符号和选择表达式
	1. 选择表达式是指访问数组/map/结构体/slice之类数据结构具体元素的表达式，调用其他包中变量和方法不属于选择表达式
	2. 选择表达式深度
		1. x.y 是最浅深度---0
		2. x.y.z 深度为1
	3. 如果x是一个结构体类型对应的指针类型的值，则表达式x.y就是表达式(*x).y的一个速记法（别名）
3. 索引符号和索引表达式
	1. 一个索引表达式由一个基本表达式和一个索引符号组成
	2. 字符串的索引表达式不能用于赋值操作
	3. map类型的键，必须是可以使用==和!=运算符比较
		1. map的索引表达式返回的是两个值：v, ok := a[x]
		2. 获取一个map中不存在的值，并不会引起灾难性错误
4. 切片符号和切片表达式
	1. 切片符号可以操作字符串、数组、数组的指针以及切片类型
    2. a[x:y:z]
    	1. x 切片元素下界索引
    	2. y 切片元素上界索引
    	3. z 切片的容量上界索引
    	4. 0 <= 元素下界索引 <= 元素上界索引 <= 容量上界索引 <= 操作对象容量
    3. 切片容量
    	1. len == y - x
    	2. cap == z - x
    	3. 如果z没有明确指定，则cap == len
    4. x,y,z 理论上必须是非负数，如果是一个表达式的话，则不存在这个限制，可以通过编译，引发runtime错误
    5. 语法糖：
    	1. a[:y]
    	2. a[x:]
    	3. a[:]
5. 类型断言   x.(T)
	1. 类型断言设计来判断动态类型中的实际类型
	2. interface{}一个特殊的接口类型，代表空接口，所有类型都是它的实现类型
6. 调用
    1. 方法和函数的调用
    	1. 方法绑定了对象
    	2. 函数是独立的
    2. 如果对象的指针绑定了方法，则使用对象本身可以直接调用该方法
    	1. s.m() 是（&s).m() 的速记法
    	2. 反过来，对象本身绑定了方法，使用对象指针无法调用
    3. 执行顺序
    	1. 当表达式中的成员是另一个表达式的时候，go语言不对执行顺序做出任何保证
    	2. 
![执行顺序示例1.png](H:\go\markdown\go语言并发编程\image\执行顺序示例1.png)
前两个表达式的执行顺序不定，所以x的实际结果可能是[]int[10,5]或[]int[20, 5]
		3. b(a())go语言中允许一个a函数的返回值直接作为另一个b函数的参数，要求a函数的返回值数量和类型与b函数的参数一一对应

7. 可变长参数
	1. 函数可变参数类型声明  ...T, 
		1. 等同于一个元素类型为T的切片类型的参数
		2. 每次调用函数时，会创建一个切片类型存放传入的实参
		3. 可变长参数必须位于形参列表的末尾
		4. func testA(arg ...string){}
	2. 将一个切片类型赋值给...T时需要在后面追加一个特殊符号...
		1. testA([]string...)   实现调用


### 数据类型
#### 基本数据类型
1. rune 
	1. go语言特有的基本数据类型，
	2. 用于存储Unicode编码
	3. 底层是一个uint32类型
	4. 4个字节
	5. “\"”  双引号转移在rune中不合法
2. byte 字节类型
	1. 底层是uint8类型
	2. 一个字节
	3. 使用单引号作为标识
3. string
	1. 底层由一个[]byte实现
	2. string属于不可变数据类型，对字符串的操作会返回一个新的字符串，而不是改变原字符串并返回
	3. 分为原生字符串字面量和解释型字符串字面量
		1. 原生字符串：两个反引号"`"之间,所见即所得，中间不存在任何转移语法
			1. 需要注意的是，回车符会被编译器移除，即“\r\n”，编译后解读为"\n"
		2. 解释型字符串：两个双引号包含的字符串序列
			1. 单引号转义"\'"，不合法
4. int/uint, int8/uint8, int16/uint16, int32/uint32, int64/uint64
	1. int/uint 宽度与操作系统有关
	2. 为了避免可以执行问题，go语言将数值类型的宽度直接体现在名字上	
	3. go语言将数值类型分为了有符号和无符号两类
	4. 这是因为go语言号称是一个用于系统编程的通用编程语言，通过选择合适的数值类型，实现资源的高效利用
	5. 整数字面量
		1. 十进制
		2. 八进制，以“0”为前缀
		3. 十六进制，以“0x"为前缀
5. float32/float64
	1. 缩写：12E+2 表示12 * 10^2  E+2  表示10的2次方
	2. .234  float类型前后无意义的0可以省略
	3. float数据类型无法准确表达0.1，十进制转换二进制的时候，会有精度损失，在进行运算时，会被比较大的乘数放大该误差
	4. 
![float转换二进制.png](.\image\float转换二进制.png)

	5. [float数加减法原理](https://blog.csdn.net/xingqingly/article/details/18981671)
6. complex64/complex128
	1. complex64:s实部和虚部都是float32类型
	2. complex128：实部和虚部都是float64类型
7. bool（true/false）
	1. 一个字节

#### 数组（Array）
1. 声明变量：   [n]T
	1. 数组的长度是数组类型的一部分，声明完毕的数组是不可变类型（指的是数组本身而不是其中元素的字面值）
	2. 对数组使用比较运算符：只有数据类型，长度，元素字面值完全一样，才相等
	3. 数组元素类型，可以是基本数据类型，也可以是复合数据类型，还可以是自定义类型
2. 初始化：
	1. 可以部分初始化
		1. [3]int{2:333}, 索引为2的元素赋值为333，其他元素为默认值
		2. 使用部分初始化，部分元素指定的索引值，后面跟着的元素索引递增，警惕有越界行为
	2. 可以动态决定数组的容量值
		1. [...]string{"hello", "world", "helloworld"}, 同样是声明并初始化array，根据元素的数量，确定数组容量
3. 属性
	1. 数组类型属于值类型，传递过程中属于值传递
	2. 数组声明后，即完成初始化动作，拥有一个都是默认值元素的数组
	3. 每次将数组赋值给一个变量/传递个函数时，会隐式的创建一个数组备份，可以通过显式的获取地址指针，避免这个copy
	4. 数组的长度不可变，通过合理的规划可以有效避免内存的二次分配（费时费力），缺点就是不够灵活
	5. 数组的地址值 == 数组第一个元素的地址值
4. 操作：
	1. 通过索引值，可以获取/赋值 数组的元素
	2. k,v := range [3]int 

#### 切片（slice）
1. 定义
	1. 切片类型，可以看成数组的一种包装形式
		1. 切片是针对底层数组中某个连续片段的描述符
		2. 一个切片值总会持有一个对某个数组值的引用
		3. 一个切片值一旦被初始化，就会与一个包含了其中元素值的数组值相关联，这就是底层数组
		4. 多个切片值可能会共用同一个底层数组，所以对同一个底层数组元素的改变，会反馈到多个切片上，有趣
	2. 切片包装的数组成为该切片的底层数组
		1. 切片的容量与其持有的底层数组长度有关系
	3. 类型表示： []T
		1. 切片类型中T可以是任意一种有效的Go语言数据类型
	4. 索引值：
		1. 使用自动推导类型，所以只只要是非负整型就可以
		2. 使用make时，指定切片长度后，再增加切片长度需要使用append函数
	5. 切片类型属于引用传递，字面值中保存着第一个元素的内存地址

![slice结构.png](.\image\slice结构.png)

2. 初始化
	1. make([]T, x, y)
		1. x 长度，y 容量
	2. 数组[x:y:z]
		1. len = y - x
		2. cap = z - x
		3. 不显式的指定z，cap = len = y-z
3. 属性
	1. 切片类型的零值为nil，初始化之前，一个切片类型的变量值为nil
	2. 切片的底层实现：一个切片值总会持有一个对某个数组值的引用
		1. 把一个切片值复制多分，或者针对底层数组的某个生成多个切片，这种情况下，多个切片值会共用同一个底层数组
		2. 对切片值中的元素值的修改，实质上就是对其底层数组中对应元素的操作
		
	3. 切片值的容量与底层数组的长度有关
		1. 将切片理解成为底层数组的一个推拉窗口，外界通过这个窗口操作底层数组对应片段
		2. 0 <= 长度下界索引 < 长度上界索引 < 容量上界索引 <= 底层数组长度
		3. 长度下界/上界索引，决定了当前切片能操作的底层数组元素
		4. 容量上界索引决定了切片能操作底层数组的最大范围
		5. 容量上界索引的出现，很好的解决了切片动态扩容时，底层数组中敏感数据的隔离，显式的指定容量上界索引后，切片动态扩容时超过容量上界，会生成另一个底层数组，严格保护原底层数组的数据安全
		6. 


4. 操作
	1. 扩容：
		1. 将切片扩容至容量上界，s1 = s1[:cap(s1)]
		2. 达到索引上界后，再扩容需要借助append函数
		3. append函数：
			1. 扩容后未超过底层元素上界，则底层数组不变，新增元素顺序覆盖底层数组中元素。
			2. 扩容后超过底层数组上界，则保留切片原有元素，新生成一个底层数组，不影响原底层数组
	2. 拷贝:
		1. 将一个切片赋值给另一个变量，相当于浅拷贝该切片
		2. 实现深拷贝：
			slice1 = nil
            slice1 = append(slice1, slice2...)
    3. copy:
    	1. copy(dst, src)
    	2. 要求连个切片中元素类型完全一致
    	3. 实际进行复制的元素个数取决于较短切片的长度
    	4. copy过程中被忽略的元素，不会覆盖到dst底层数组中，是直接舍弃
    
#### map
1. 定义
	1. map是哈希表（Hash Table）的一个实现
	2. Hash Table 是一个实现了关联数组的数据结构，计算机科学领域中最有用的数据结构之一
	3. 关联数组：用于代表键值对的集合的一种抽象数据类型
	4. 一个键值对几何中，一个键只允许出现一次
	5. Hash Table中键值对之间无序
2. 声明
	1. map[K]T
	2. K的类型必须可以使用==或!=进行比较（除map/slice之外基本都可以）
	3. 接口类型作为键时，接口类型中的动态类型再函数运行过程中必须始终是可比较的状态，否则发生runtime异常
3. 初始化
	1. 只进行了声明动作的map类型，其长度为0，字面量为nil
	2. 空map可以进行读操作，获取一个键类型的默认值和一个bool值
	3. 对空map进行写入操作，会引发panic异常
4. 属性
	1. map类型属于引用类型，作为函数参数时，对map进行修改会影响调用者
	2. go语言中没有引用传递的概念，传入函数后的修改是否会影响调用者，只取决于传入值本身是值类型还是引用类型
	3. 可以使用len(map)函数获取map的长度
	4. map在go语言中不是并发安全的，
		1. 可以使用sync.RWMutex实现并发安全
5. 操作
	1. 读操作
		1. v, ok := map[k]
		2. v是map中键对应的值
		3. ok是取值是否成功，如果map中不存在k，则v为默认值，ok返回false，ok可以有效消除歧义（v本身保存的就是默认值，无法判断是否获取成功）
	2. 写操作
		1. map[k] = v
		2. 随时都可以向map增减键值对
		3. 向未初始化的map中增加元素会引起panic
	3. 删除元素
		1. delete(map, k)
		2. delete函数没有返回值，不管是否操作成功，都不会引发错误

#### 函数和方法
##### 函数
1. 概念
	1. go语言中，函数类型是一等类型，
		1. 意味着函数可以作为一个值来传递和使用
		2. 这个特性，是go和python可以轻松实现闭包的原因
		3. 函数值是一种引用类型
	2. 函数类型：
		1. 指代所有可以接受若干参数并能够返回若干结果的函数
		
2. 类型表示法
	1. 使用func关键字
	2. func 函数签名  
		1. 函数签名包括参数声明列表和结果声明列表
		2. 声明函数类型时，可以省略参数声明列表中的所有参数名称
		3. 可以使用边长参数  ...string, 保留在一个slice中
		4. go语言允许多返回值
			1. 让每个结果职责单一，易于理解，和实现，省去了逐层throw-catch的麻烦
			2. 从不同角度体现函数内部操作

3. 值表示法
	1. go语言中，函数是值的一种
	1. 函数类型的零值是nil
	2. 命名函数
		1. 命名函数的声明可以省略掉函数体，这意味着该函数会由外部程序（如汇编语言）实现，而不会由go语言程序实现
	3. 匿名函数
	4. 函数被调用时，参数列表和结果列表中所有声明的变量会被初始化为默认值
	6. 一个函数字面量可以被赋给一个变量，也可以被直接调用，再次强调，go语言把函数作为值这一特性

4. 属性
	1. 函数类型是go语言的数据类型之一
		1. 使用type关键字自定义类型
		2. 声明函数类型，省略函数名，变量名，函数体 
	2. 函数是封装一段代码的最小单元


##### 方法
1. 定义
	1. 方法就是附属于某个自定义的数据类型的函数
		1. 系统内置类型不能绑定自定义方法
	2. 方法调用，需要一个相关联的自定义类型对象作为前提

2. 指针方法/值方法
	1. 值方法：
		1. 绑定的接收者是自定义数据类型值
		2. 绑定值的方法，只有值对象可以调用
		3. 值方法对绑定对象字段的操作，不会影响调用函数，值传递
	2. 指针方法
		1. 绑定的接收者是自定义数据类型的指针对象
		2. ，值对象/指针对象都可以进行调用
		3. 指针方法内的对接收者属性的修改，可以影响调用函数


#### 接口
1. 定义
	1. GO语言接口：一组方法的集合代表
	2. 只要一个数据类型（与之对应的指针类型）绑定的方法集是某一个接口的超级，就可以判定该类型实现了这个接口
	3. go语言接口的实现，是非侵入式的
	4. 一个接口类型的值，可以与任何实现了这个接口类型的数据类型值进行绑定
2. 类型表示
	1. 接口是一组方法的集合
	2. 具体值取决于实现接口
	3. 接口中不能嵌套接口本身（直接嵌套，间接嵌套都不行）
3. 属性和基本操作
	1. 接口通过匿名字段实现继承
	2. 适用类型断言，判断实现方法的具体类型

#### 结构体
1. 定义：
	1. 结构体类型包含若干个命名元素（又称为字段)
	2. 可以与若干个方法相关联
2. 类型表示
	1. 命名结构体类型
		1. 关键字type  结构体类型名称  关键字struct   {结构体字段生命}
	2. 匿名结构体类型
		1. 相对于命名结构体类型声明，没有type和结构体类型名称
		2. 匿名结构体类型，可以作为一个变量声明动作的类型
		
		![匿名结构体作为变量类型.png](.\image\匿名结构体作为变量类型.png)
		3. 匿名结构体类型是一次性类型，在临时存储数据和传递的场景中较适用
	3. 结构体标签
		1. 结构体字段声明时可以通过一个字符串字面量作为该字段的标签
		![结构体字段标签.png](.\image\结构体字段标签.png)
        2. 该标签在通常情况下，是不可见的
        	1. 可以通过reflect查看
        	2. 供json封装时使用
    4. 初始化
    	1. 初始化结构体时，字段名称和字段值作为键值对形式存在
    	2. 初始化时，键可以忽略，但要忽略就都不能写，要提供某个键，则所有的都需要提供
    	3. 结构体零值
			1. test_struct{}， 作为该类型结构体的零值
			2. 这样子初始化后，各字段会拥有一个字段的默认值

3. 属性
	1. 结构体中字段，通过首字母大写控制包外的访问权限
		1. 首字母大写，外部可见，可操作
		2. 首字母小写，该字段为私有字段
	2. 字段声明语句中，同一类型的字段可以在同一行声明（不推荐）
	3. 匿名字段：字段声明中只有类型，没有指定名称
		1. 匿名字段的类型
			1. 一个数据类型的名称
				1. 这个数据类型的非限定名称隐式的作为该字段的名称
			2. 一个非接口类型对应的指针类型
				1. 这个指针类型所指的数据类型的非限定名称会作为该字段的名称
				2. 非限定名称：P.T ,非限定名称为T
		2. 匿名字段嵌入
			1. 声明的结构体自动拥有嵌入的匿名字段所拥有的方法
			2. 嵌入类型的方法接收者，仍然是该嵌入类型，而不是新声明的结构体
			3. sub 拥有text()方法，则可以用obj.text()进行调用，实际是obj.sub.text()的速记法
			4. obj绑定了sub中同名方法（参数及返回值不影响，只看名称）则obj对sub中方法实现了隐藏，仍然可以通过obj.sub.text()进行调用
			5. 被嵌入结构体类型的方法和字段的隐藏是可以交叉进行的，也就是说，同名的方法可以隐藏同名字段，反之也成立
			6. 多级嵌入的情况下，嵌入深度较浅的方法隐藏嵌入较深的
			7. 同一级嵌入中有同名字段/方法，则报错，编译器不确定改选哪个
			8. 
	4. 嵌入
		1. go语言中，只有嵌入的概念，没有继承的概念
			1. 不存在父类型，子类型的说法，所以上级结构体的字面量，不能赋值给嵌入类型的字面量
	5. 别名
		1. 通过type关键字，可以为数据类型生成一个别名
		2. 新生成的别名拥有源别名的一切字段，但不拥有其绑定的方法
		
#### 指针
1. 定义
	1. 指针是一个代表着某个内存地址的值（虚拟内存）
	2. 通常，这个内存地址时存储在内存中某一变量的起始位置
	3. go语言对指针的支持介于java和c++之间，既没有像java一样取消对指针的直接操作，另一方面避免了c/c++由于对指针滥用造成的安全及可靠性问题
2. 类型表示
	1. 使用操作符"*"
	2. uintptr类型，是go语言中专门用于存储内存地址的数据类型
		1. uintptr类型属于数值类型，保存一个32/64位无符号整数
		2. 它的值是指针类型值的位模式（bit pattern）
3. 值表示
	1. 可寻址：
		1. 一个有效的指针类型，是实际储存在内存中，并且内存地址指向变量在存储中的起始位置
	2. 取地址操作符&
	3. 取值操作符*
4. 属性
	1. 指针类型是引用类型，零值为nil
	2. 提供对指针类型的有限操作
5. 操作
	1. unsafe包中的方法，违反了go语言的类型安全
	2. unsafe.ArbitraryType 
		1. int类型的一种别名
		2. 实际上，可以代表任意Go语言表达式的结构类型
	3. unsafe.Pointer
		1. 代表了unsafe.ArbitraryType类型的指针类型
		2. 就是说，任意类型的指针类型都能转换为unsafe.Pointer
		3. unsafe.Pointer 可以转换成任意类型的指针类型，需要注意，如果实际内存储存格式与转换后的类型不符，取值的时候会引发panic错误
		4. unsafe.Pointer可以与uintptr类型互相转换，也就是或，可以通过转换为uintptr类型执行指针加法，位移
	4. unsafe.Offsetof()
		1. 可以获取某字段由在所属结构体类型中的存储偏移量，单位是字节
	5. 恒等式
		1. uintptr(unsafe.Pointer(&s)) + unsafe.Offsetof(s.f) == uintptr(unsafe.Pointer(&s.f))

#### 数据初始化
1. new
	1. new函数用于为某一数据类型分配内存空间，并将清零分配到的内存空间，将这块内存地址作为结果返回。
	2. 申请内存地址后，该内存地址存放该类型的默认值（清零），所以使用new创建引用类型后，不能直接使用，引用类型的默认值是nil
	3. new创建引用类型后，底层对应元素位置完成初始化，引用类型值则是一个指针类型的零值nil，两者之间的映射关系仍未建立，所以引用类型变量还不能使用
2. make
	1. 能用来创建引用类型（Channel, slice, map）的值，创建内存地址后，还会对该变量进行相应的初始化
	2. 返回引用类型的值
3. 变量值的创建可以使用三种方式：
	1. 字面量创建
	2. new关键字，返回指针类型
	3. make关键字，创建引用类型，返回变量值


### 数据的使用
#### 赋值语句
1. 赋值运算符 =
	1. 赋值操作的接受者，必须是可寻址的
	2. 赋值操作符的右边
		1. 如果是一个无类型常量，可以赋值予任何拥有相同底层类型的变量值
		2. 如果是一个有类型值，只能赋值给本类型变量
		3. 
![赋值操作.png](.\image\赋值操作.png)

2. 平行赋值---  多重赋值
	1. 通常，平行赋值，“="两边表达式的数量需要相等
	2. 特殊：
		1. 调用多返回值的函数或方法
		2. 字典类型取值操作
		3. channel接受操作
		4. 类型断言
3. 非基本赋值操作，在赋值运算符前面插入算术运算符，只有前置，没有后置插入
	1. 顺序执行，限制性算数运算符，再执行赋值运算符
	2. 非基本赋值运算就是普通赋值运算的简写，所以非基本赋值操作不能用于平行赋值

4. 执行顺序（对于平行赋值有意义）
	1. 分为两步
	2. 第一阶段，“=”两边分别按通常顺序，分别执行完取值操作
	3. 第二阶段，按照通常顺序，顺序执行赋值操作
	4. 同一表达式如果后面的赋值操作引起了panic操作，前面的赋值仍然有效
	5. 
![赋值操作顺序.png](.\image\赋值操作顺序.png)


### 常量与变量
#### 常量
1. 定义
	1. const关键字，const关键字是一个类型修饰符
	2. 常量的赋值必须与声明同时进行，且只能赋值一次
2. 常量分类
	1. 程序中出现的未赋予标识符的数值，是一种默认常量
	2. 使用const关键字定义常量
		1. 定义的常量，可以显示的指定数据类型
			1. const s1 string = "hello"
		2. 也可以只指定标识符，不指定数据类型
			1. const s1 = "hello"
			2. 不指定数据类型的常量，处于一种特殊的状态--- 属于一种untyped T 类型常量，仅仅是一个值，还没有被严格定义为具体类型，所以可以参加混合类型运算（go不允许混合类型运算，就创造一个无类型状态^_^）
			3. 无类型常量有一个默认类型。因为无类型，所以可以赋值给所有兼容默认类型的变量，不会引发异常
			4. 无类型常量转换为具体类型值时，如果具体类型没有指定（则会使用默认类型）---自动类型推导/格式化输出
			5. 默认数据类型：
				1. string   --- string   0
				2. int      --- int    0
				3. float    --- float64  0
				4. byte     --- int32 120
				5. complex  --- complex128  (0+0i)
3. 赋值/初始化
	1. 常量，在代码编译阶段就会进行初始化（类型/赋值），不论定义在全局还是局部
	2. 数值型常量拥有非常高的的精度（一般有256位进行保存，保存的数据超过go语言中的任何类型的范围），可以代表任意精度的数值，永远不会出现溢出的情况
	3. go语言允许使用并行赋值进行常量赋值
		1. const v1, v2, v3 = 1, "hello", true
		2. 并行赋值的各常量之间相互独立
	4. 允许合并多条常量赋值操作，使用括号括起来标识
		1. 
![赋值操作顺序.png](.\image\赋值操作顺序.png)
	5. iota赋值操作
		1. 
![iota赋值常量.png](.\image\iota赋值常量.png)
	6. 只有字面常量和常量表达式可以作为常量的值
		1. 这里着重强调的是，不能使用变量作为值进行常量赋值

#### 变量
1. 定义
	1. 为了避免类似C语言中的隐式类型转换，造成运算时产生的隐患，go语言不允许不同类型之间进行类型转换，不允许不同类型之间进行运算
	2. 不同类型数据进行运算时，需要显式的进行类型转换
2. 声明
	1. 以var为关键字
	2. 可以使用并行赋值
	3. 赋值操作的右边可以是字面常量，常量，表达式，变量
	4. 自动推导类型
		1. 只能用于函数体内
		2. 不能，也不需要提供变量类型
		3. 自动推导类型进行并行赋值的时候，左侧标识符中起码要有一个是新变量
	5. 注意_ 不是一个新变量，不可以进行声明操作
	6. 可以拆分到括号内进行集中赋值
		1. 不可以省略类型
	7. 可以只声明，不赋值
3. 局部变量
	1. 函数体内部，局部变量会屏蔽同名全局变量

### 可比性和有序性
#### 类型的恒等
1. 两个命名类型
	1. 名称不同，他们不相等，就是说别名类型和它的源类型不同
2. 一个命名类型和一个匿名类型不恒等
3. 两个匿名类型，
	1. 需要相同的字面结构，且对应位置上的组成部分具有相同的类型，两个匿名类型才相等
#### 数据的可比性和有序性
1. 定义
	1. 可比性：可比较是否相等，操作符==或!=
	2. 有序性：可比较大小，操作符<,>等

2. 各类型可比性
	1. bool具有可比性，不具有有序性
	2. 整型有可比性，也有有序性
	3. 浮点型有可比性，也具有有序性
	4. 复数类型具有可比性：通过比较实部和虚部得出
	5. 字符串具有可比性和有序性
		1. 按位比较，知道得出结果
	6. 指针类型具有可比性，不具有有序性
	7. channel类型具有可比性
	8. 接口类型具有可比性
		1. 要求所拥有的动态类型和相同的动态值
		2. 非接口类型，如果实现了接口，则可以于该接口的值进行比较
	9. 结构体，如果拥有的所有字段都具有可比性，则可比较
	10. 数组具有可比性
	11. 切片类型、字典类型、函数类型不具有可比性
		1. 作为特例，这些值可以与nil进行比较

### 类型转换
1. 定义
	1. 类型转换：go语言中有灵活的自定义类型，只要符合定义规范，都拥有转换操作
2. 操作
	1. 数值类型转换（变量转换）
		1. 向较少二进制位转换，舍弃多余的高位数
		2. 向较多二进制位转换
			1. 如果有类型，使用符号位数字补高位空位
			2. 如果没有类型，使用0补位
		3. 浮点数向整数转换，小数位抹除
		4. 向浮点数转换，会根据目标类型精度进行舍入操作，有精度损失
	2. 类型转换产生一个新值，不影响原值
	3. string 可以转换[]byte/[]rune，
		1. []byte 字节切片，保存utf-形式储存的字节码，每个元素标识某个字符的全部或部分UTF-8编码之
		2. []rune 字符切片，保存某个字符的Unicode代码点
		3. byte和rune属于整数值的一种，可以赋值给整型变量
			1. byte 底层是int8
			2. rune 底层是int32
		4. 当一个有符号整型或无符号整型向字符串类型转换时，会产生一个字符串
			1. 被转换的整数值应该是一个有效的unicode代码点

### 内建函数
1. close()  : 关闭channel
2. len(), cap()
3. new(), make()
4. append(), copy
5. delete
6. complex(), real(), imag()，处理虚数
7. panic,recover
	1. recove返回值为nil：
		1. panic参数为nil
		2. panic没有调用
		3. recover没有在defer中调用