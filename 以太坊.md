# 以太坊

## 1 背景

> 以太坊愿景是，将整个网络建设为一个大型的云计算机
>
> 以太坊大约15秒左右进行打包操作

## 2 共识算法

1. 以太坊的前三版本（目前为止）还是使用POW机制

2. V深在这点上的看法：

   > 区块链上只有三类用户群是可以实现去中心化的
   >
   > 1. 运算能力的所有者对应标准的工作量证明算法（POW)
   > 2. 股东对应钱包软件中的各种权益证明算法（pos）
   > 3. 社交网络中的成员对应着联盟式的共识算法
   >    1. 瑞波共识模式：是一种较封闭的成员列表中的人拥有权力，外部成员不具有权力，新增成员需要超过51%列表成员同意才行的机制
   >    2. 对系统性腐败毫无抵抗力

## 3 solidity

> solidity编写完成，通过编译，BYTECODE(合约的二进制模式)已经上传到了网络，在其他地方调用时，需要知道ABI
>
> 调用智能合约流程：js代码  --> ABI  --> BYTECODE 
>
> solidity中合约的含义就是一组代码（函数/和状态变量），智能合约位于以太坊的一个特定地址上，就是跟合约账户一起存储在链上
>
> 所有的标识符都只能使用ASCII字符集，UTF-8编码数据可以使用字符串变量存储

### 3.1合约包含的元素

 	1. 状态变量（state variables）：就是成员变量，该数据上链
 	2. 函数（Function）
 	3. 函数修饰符（Function Modifiers）
 	4. 事件（Events）
 	5. 结构类型（Structs Types）
 	6. 枚举（Enum Types）
 	7. Mapping(key  => value)

### 3.2 数据类型

> 不可变类型：不管作为参数传递，还是对其他变量进行赋值，都是给对方一个完全无关的副本
>
> 可变类型：
>
>  	1. 作为函数参数，是传递了一个完全无关的副本，等同于不可变类型
>  	2. 作为临时变量赋值，则是将引用的底层传递过去，做修改操作会影响底层
>  	3. 赋值给一个状态变量（全局变量），总是创建一个完全无关的副本

#### 3.2.1 不可变类型

 1. 布尔（booleans）

 2. 整型（int/uint）

     	1. 默认为int256, uint256，
     	2. 以int8开始，8为间隔，最大int256

 3. 地址（Address）

     	1. 20比特，是一种类型，有本身的属性
     	2. 底层是160位的值，本身不允许进行任何操作，可以强制转换位uint160类型
     	3. address类型可以存储合约地址或外部人员的密钥对
     	4. 属性：
          	1. balance:余额， addr.balance，只有这个是属性，其他的是方法
          	2. transfer:转账方法 addr.transfer(uint256)，单位是：v，转账失败抛出系统异常
          	3. send: 转账方法，存在一定安全风险，转账失败不抛出异常，返回一个bool值，需要显示的进行判断
          	4. call:
          	5. 

 4. 字节数组(bytesn,n表示数组长度，单位是字节）

     	1. 类似python元组
     	2. 使用length方法获取长度
     	3. 长度不可以修改
     	4. 其中元素不可以修改
     	5. 可以使用索引访问对应元素
     	6. 以字符串的形式进行赋值（单双引号都可以）
     	7. 底层使用ASCII码（16进制表示）存储

 5. 枚举（emums)

     1. 枚举至少有一名成员，默认类型位uint8，元素足够多时，自动转换位uint16

     2. 从0开始

     3. 与uint8之间可以进行显式的互转

     4. 相当于一种自定义类型

        ```solitidy
        enum TestE {
        	t1,
            t2,
            t3
        }
        TestE day = TestE.t2;
           
        function setDay(TestE _num)public{
            day = _num;
        }
        function getDay()public view returns(uint8){
            return uint8(day);
        }
        ```

 6. 有理数和整型

 7. 函数（function）

#### 3.2.2 可变类型

	> solidity中的length方法有个特殊的用法，可以使用obj.length = 10 强制将长度变为10.

1. String  -- 注意与其他语言中作区别

   1. 不支持length/索引/push方法
   2. 引用类型
   3. 可以通过bytes方法进行转换
   4. 可以接收”字符串"

2. 不定长字节数组(bytes)

   1. 初始化
      1. bytes public b1 = new bytes(1);
      2. bytes public b2;
   2. 引用类型
   3. 支持索引
      1. 索引不可以越界，要使用可以通过new/push进行内存分配或者直接修改length进行内存分配
   4. 有length/push方法，
      1. 使用push方法，会自动进行内存分配
      2. push方法相当于go中的append函数
   5. 可以修改
      1. b1 = b2
      2. b1 = bytes(str)
   6. 以十六进制格式赋值
      1. 每个元素都是bytes1类型。
      2. bytes类型和bytesn 类型之间不能相互转换，只能通过先申请等长内存的bytes变量，然后通过循环索引赋值，copy一份

3. mapping

   1. 复杂数据类型
   2. 会将作为key的变量映射为无符号整型
      1. 键的类型允许除map外的所有类型，
      2. 值的类型无限制，
   3. 无法获取key 或value的列表，只能从key获取到value，注意这种特性
      1. 访问一个不存储的key，返回0或false
   4. map类型，仅能用来定义状态变量，或者是在内部函数中作为storage类型的引用
   5. 不支持length
   6. 定义方法：mapping(string => int256) mname;
   7. 赋值方式：
      1. mname["zhangsan"] = 11;

4. 自定义数组

   1. 定长自定义数组：
      1. T[K]  name, 例如：uint[5]  name:   静态类型[长度]    变量名
      2. 内容可变
      3. 长度不可变，不支持push
      4. 支持length方法
   2. 不定长自定义数组
      1. 定义格式：T[], 例如：uint[] name: 静态类型[]  变量名
      2. 内容可以修改
      3. 可以改变长度（仅限storage类型）支持length、push方法。

5. 结构体

   1. 定义方式与go相同，

      1.  struct student {

         ​	string name;

         ​	uint age;

         }

   2. 赋值方法

      1. student stu1 = student("zhansan", 1)
      2. student stu2 = student({name:"lisi",age:20})

   3. 使用点号操作属性

      1. stu1.name = "wangwu"

6. 

#### 3.2.3 关键字

1. constrant: 标识不会修改成员变量（状态变量），方法中访问了状态变量但没有进行修改，使用constrant

   1. 使用了constrant，但没有状态变量进行修改，不会报错，函数外的成员变量也不能正常赋值。相当于将方法中变量强制转变为局部变量

2. view: 与constrant 含义相同，由于不同版本造成

3. public: 标识全局变量/方法，可以调用 

   1. 底层实际是自动生成了一个函数，允许在合约外访问修饰的内容（函数/变量）
   2. function test()public{}  int public n1

4. private: 全局可见，不可调用

5. constract:作用与java中的class类似，可以在另一个constract中，使用new创建一个对象，然后调用可调用的内容

   1. ```js
      contract test1{
          struct student {
              string name;
              int256 age;
          }
          student s;
          function news(string name, int256 age) public{
              s.name = name;
              s.age = age;
          }
          
          function getName()public view returns(string){
              return s.name;
          }
          
          function setName(string name)public{
              s.name = name;
          }
      }
      
      contract test2{
          function gettest1()public returns(string){
              test1 obj = new test1();  //创建一个对象 
              obj.news("lisi", 12);
              obj.setName("zhangsan");
              return obj.getName();
          }
      }
      ```

6. pure: 函数中没有调用任何状态变量，不使用constrant/view，使用pure修饰函数

7. this：表示合约本身地址.

   1. 不推荐使用this直接进行转账，使用address(this).balance访问余额
   2. 访问合约本身的变量不需要使用this关键字（与其他编译型语法）

8. payable: 表示可以进行转账参数，用来修饰函数

9. memery

   1. 可以修饰变量，表示该变量为值类型，数据不是永久存在的，存放在内存中，超过作用域就会被回收，无法访问
   2. 可变类型和不可变类型，在作为函数参数时都默认是memery，要使用引用类型特性，需要指明storage
   3. 可变类型作为临时变量tmp时，则类型为storage，将全局中可变类型变量str对其赋值时，修改tmp的值也会印象str的内容

10. storage

    1. 可以修饰可变变量，表示该变量为引用类型，相当于获取了地址值，传递时只传递地址，新旧变量指向的内存是同一区域，相互之间会干扰
    2. 使用了storage的函数，不能使用public参数，就是说不能够对外开放
    3. function setVal2(string storage str1)private{// TODO}
       1. private 是必须的，因为引用类型不能暴露数据是永久保存的（意味着会上链）

### 3.3 事件

> 使用event关键字，可以定义在函数的哪一行发送事件
>
> 如：event Sent(address from, address to,uint  amount );
>
> 事件在合约外通过监听器接收
>
> 如：Coin.Sent().watch({}, "", function(error, result){
>
> ​	if (!error){
>
> ​		// TODO
>
> ​	}
>
> })
>
> 所有的事件都包含from,to,amount三个参数，便于追踪事务

### 3.4 匿名函数

> 常用于进行转账交易





## 4 以太坊虚拟机（EVM）

### 4.1 概述

> EVM是智能合约的运行环境，该环境是沙盒封装的，也就是说是完全隔离的：
>
> 1. 无法访问网络、文件系统、其他进程
> 2. 智能合约之间的访问也受到限制

### 4.2  账户

> 以太坊中有两类账户
>
> 对于EVM来说，这两类账户其实是一样的
>
> 每个账户都有一个键值对形式的持久化存储，其中key和value的长度都是256位，这个操作称为存储
>
> 每个账户都有一个以太币余额（balance)，单位是“Wei"，

#### 4.2.1  外部账户

>  由密钥对控制，地址由公钥决定

#### 4.2.2 合约账户

> 由和账户一起存储的代码控制，地址在合约创建的时候确定

### 4.3 交易

>  交易：从一个账户发送到另一个账户的消息，消息中包含一个二进制数据（合约负载）和以太币。
>
> 如果目标账户含有代码，此代码会被执行，并以payload作为入参

#### 4.3.1 两种交易

1. 普通交易：目标地址不为空
2. 创建合约：目标地址是零账户（账户地址为0），此交易会创建一个新合约
   1. 合约的地址不是零地址，而是通过合约创建者的地址和从该地址发出过的交易数量计算得到的（所谓的"nones"）
   2. 用来创建合约的payload会被转换为EVM字节码并执行，执行的输出将作为合约代码永久存储
   3. 也就是说，创建一个合约，不需要发送实际的合约代码，而是发送能够产生**合约代码的代码**
   4. 在合约创建过程中，对应的代码都还是空的，所以直到构造函数执行结束，都不应该进行调用

### 4.4  Gas

> 以太坊中，每笔交易都需要收取一定的Gas，

#### 4.4.1 目的

1. 限制执行交易的工作量
2. 为交易支付费用

#### 4.4.2 交易过程

1. 用户在创建交易时，会发送gas_price和gas_limit，两者相乘就是用户需要预付的交易费， 
2. EVM执行交易的时候，会按照特定规则逐渐花费gas
3. 交易结束后剩余gas原路返回。
4. 如果执行中gas耗尽，触发一个out-of-gas异常，并回滚相关操作（调用帧）。

### 4.5  存储，内存和栈

#### 4.5.1 存储

> 这是个专有名词
>
> 以太坊中每个账户都有一块持久化内存区域称为存储
>
> 将256位字映射到256位字的键值存储区，在合约中枚举存储是不可能的，且读存储的相对开销很高，修改存储的相对开销更高
>
> 合约只能读写存储区中属于自己的部分

#### 4.5.2 内存

> 合约会试图为每一次消息调用获取一块被重新擦拭干净的内存区域
>
> 内存是线性的，可按字节级寻址，但读的长度被限制为256位，而写的长度可以是8位或256位。
>
> 内存扩容以字为单位（每个字是256位），扩容会花费一定的gas，扩容越大，费用越高（以平方级别）

#### 4.5.3 栈

> EVM基于栈运行（不是基于寄存器运行）
>
> 栈最大为1024个元素，每个元素长度是（256位）。
>
> 对栈的访问只限于栈顶
>
>  	1. 允许拷贝最顶端的16个元素中的一个到栈顶，或者交换栈顶元素和下面16个元素中的一个
>  	2. 所有其他操作都只能去最顶的n个(具体个数由操作确定)
>  	3. 运算后，将结果压入栈顶
>  	4. 要访问栈区较深的元素，需要先从栈顶移除其他元素

### 4.6 指令集

> EVM指令集较少，以最大限度避免可能导致共识问题的错误实现
>
> 所有指令都是针对”256位的字"这个基本数据类型进行操作（常规运算/有条件跳转/无条件跳转）
>
> 合约可以访问当前区块的相关属性：编号/时间戳

### 4.7 消息调用

> 合约通过消息调用方式调用其它合约或者发送以太币到其他非合约账户。
>
> 消息调用同交易一样：有一个源、目标、数据、以太币、gas、返回数据
>
> 交易的实际操作：由一个顶层消息调用组成，顶层消息调用可以创建更多的消息调用
>
> 每发起一个子消息调用，都会发送相应的gas，如果发生out-of-gas之类异常，会触发一个手工异常
>
> 每发起一个子消息调用，都会分配相应内存，用来存放调用返回内容

### 4.8 委托调用（delegatecall）/代码调用/库

> 委托调用：目标地址的代码将在发起调用的合约的上下文中执行，并且msg.sender和msg.value不变
>
> 也就是一个合约可以在运行时从另一个地址动态加载代码。存储、当前地址和余额都指向发起调用的合约，只有代码是从被调用地址获取的   --- 相当于实现了库

### 4.9 日志

> 一种特殊的可索引数据结构，存储的数据可以一路映射到区块层级。
>
> 合约创建之后就无法访问日志数据，这些数据可以从区块链外高效的访问  

### 4.10 创建

> 合约通过调用create calls创建其他合约（不是调用零地址），
>
> 不同于普通消息调用：负载会被执行，执行的结果被存储为合约代码，调用者/创建者在栈上得到新合约的地址

### 4.11 自毁

> 合约代码从区块链上移除的唯一方式：在合约地址上执行自毁操作selfdestruct。
>
> 合约账户剩余以太币会发送给指定目标，其存储和代码从状态中移除
>
> 尽管一个合约的代码中没有显式地调用 `selfdestruct` ，它仍然有可能通过 `delegatecall` 或 `callcode` 执行自毁操作。
>
> 目前，外部账户不能从状态中移除